---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Método de Pólya - Parte 2/4' -->

# <!-- fit --> Método de Pólya
## Etapa 2: Concebir un Plan
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 2 minutos
- Objetivo: Enseñar a diseñar soluciones antes de implementarlas.
- Gancho: "¿Alguna vez construyeron un mueble de IKEA sin mirar las instrucciones? Seguro les sobraron tornillos. Programar sin planificar es igual."
-->

---

<!-- _class: inverse -->

# <!-- fit --> Etapa 2
## Concebir un Plan

<!--
NOTAS DEL ORADOR:
- Transición: Ya entendemos el problema. Ahora vamos a diseñar la solución.
- Todavía NO tocamos el teclado para escribir código.
-->

---

<!-- _header: 'Objetivo' -->

# Diseñar la estrategia

**Después de comprender:**
* Diseñar estrategia de solución
* ANTES de escribir código
* Descomponer en partes más simples

**Seleccionar:**
* Herramientas algorítmicas apropiadas
* Estructuras de datos adecuadas

<!--
NOTAS DEL ORADOR:
- El plan es un puente entre el problema y la solución.
- Es el momento de tomar decisiones de diseño: ¿Uso una lista o un diccionario? ¿Necesito ordenar los datos?
-->

---

<!-- _header: 'Estrategias' -->

# Descomposición del problema

**Divide y conquistarás:**
* Dividir en partes más pequeñas
* Subproblemas independientes
* Establecer orden de resolución

**Ejemplo:**
* Problema: Promedio de calificaciones
* Subproblemas:
  1. Leer calificaciones
  2. Sumar calificaciones
  3. Dividir por cantidad

<!--
NOTAS DEL ORADOR:
- Top-Down Design.
- Un problema grande es intimidante. Tres problemas pequeños son manejables.
- Si no sabés cómo resolver el problema entero, resolvé una parte.
-->

---

<!-- _header: 'Estrategias' -->

# Identificación de patrones

**Preguntas útiles:**
* ¿Se parece a algo que ya resolviste?
* ¿Hay una técnica conocida? (búsqueda, ordenamiento)
* ¿Qué estructura de datos usar?

**Patrones comunes:**
* Búsqueda lineal
* Acumuladores
* Contadores
* Banderas

<!--
NOTAS DEL ORADOR:
- El reconocimiento de patrones es lo que diferencia al experto del novato.
- "Esto se parece a cuando buscamos el máximo, pero ahora buscamos el mínimo".
- Fomentar el uso de su "caja de herramientas" mental.
-->

---

<!-- _header: 'Herramientas' -->

# Herramientas de diseño

**Pseudocódigo:**
* Descripción de alto nivel
* Lógica sin sintaxis exacta

**Diagramas de flujo:**
* Representación visual
* Flujo de control claro

**Casos de prueba:**
* Ejemplos concretos
* Validar lógica antes de programar

<!--
NOTAS DEL ORADOR:
- No importa la herramienta, importa pensar.
- El pseudocódigo es excelente porque nos libera de los detalles molestos (punto y coma, paréntesis) para enfocarnos en la lógica.
-->

---

<!-- _header: 'Ejemplo' -->

# Problema: Búsqueda del máximo

**Ya comprendimos el problema...**

**Ahora: Plan de solución**
1. Inicialización
2. Iteración
3. Comparación
4. Retorno

<!--
NOTAS DEL ORADOR:
- Volvemos al ejemplo de la clase anterior.
- Mostramos la estructura del algoritmo estándar de búsqueda.
-->

---

<!-- _header: 'Ejemplo - Plan' -->

# Plan detallado

**1. Inicialización:**
* Asumir primer elemento como máximo

**2. Iteración:**
* Recorrer elementos restantes

**3. Comparación:**
* Si encontramos mayor, actualizar

**4. Retorno:**
* Devolver el máximo encontrado

<!--
NOTAS DEL ORADOR:
- Explicar por qué asumimos el primero como máximo (maneja números negativos correctamente).
- El plan debe ser lo suficientemente detallado como para que cualquiera pueda programarlo.
-->

---

<!-- _header: 'Ejemplo - Pseudocódigo' -->

# Pseudocódigo del plan

```
función encontrar_maximo(lista):
    si lista está vacía:
        retornar Nada
    
    maximo_actual = lista[0]
    
    para cada elemento en lista[1:]:
        si elemento > maximo_actual:
            maximo_actual = elemento
    
    retornar maximo_actual
```

<!--
NOTAS DEL ORADOR:
- Observar que esto es casi Python, pero se lee como español.
- Si podemos escribir esto, escribir el código es trivial.
-->

---

<!-- _header: 'Ejemplo - Validación' -->

# Casos de prueba del plan

**Caso normal:**
```
[3, 7, 2, 9, 1] → 9
```

**Caso con un solo elemento:**
```
[5] → 5
```

**Caso con negativos:**
```
[-3, -7, -2, -9] → -2
```

**Caso con duplicados:**
```
[5, 9, 3, 9, 1] → 9
```

<!--
NOTAS DEL ORADOR:
- Prueba de escritorio mental.
- ¿Funciona mi plan con estos datos?
- Si falla aquí, corregimos el plan (barato). Si falla en código, corregimos bugs (caro).
-->

---

<!-- _header: 'Validación' -->

# Antes de programar

**Asegurate de:**

1. Verificar el plan con ejemplos simples
2. Identificar casos límite
3. Estimar complejidad (tiempo y memoria)

**¿El plan es correcto?**
* Probalo manualmente
* Con diferentes casos

<!--
NOTAS DEL ORADOR:
- Validar el algoritmo, no el código.
- "¿Estás seguro de que esto va a funcionar?".
-->

---

<!-- _header: 'Otro ejemplo' -->

# Problema: Validar contraseña

**Enunciado:**
* Una contraseña es válida si:
  * Tiene al menos 8 caracteres
  * Tiene al menos una mayúscula
  * Tiene al menos un número

**Diseñá el plan...**

<!--
NOTAS DEL ORADOR:
- Ejercicio interactivo.
- Pedir sugerencias de plan.
-->

---

<!-- _header: 'Ejemplo - Plan' -->

# Plan: Validar contraseña

**Descomposición:**
1. Verificar longitud >= 8
2. Buscar al menos una mayúscula
3. Buscar al menos un dígito
4. Retornar True si cumple todo

**Pseudocódigo:**
```
si longitud(contraseña) < 8:
    retornar Falso
si no tiene mayúscula:
    retornar Falso
si no tiene dígito:
    retornar Falso
retornar Verdadero
```

<!--
NOTAS DEL ORADOR:
- Estrategia "Fail Fast" (Fallar Rápido).
- Si no cumple longitud, ni siquiera miramos las mayúsculas.
-->

---

<!-- _header: 'Estrategia avanzada' -->

# Simplificar el problema

**Técnica útil:**
* Resolver versión más simple primero
* Después generalizar

**Ejemplo:**
* Problema: Promedio de N números
* Versión simple: Promedio de 3 números
* Después: Generalizar a N

<!--
NOTAS DEL ORADOR:
- Si el problema te abruma, resolvé una parte.
- Si podés resolverlo para 3, probablemente veas el patrón para resolverlo para N.
-->

---

<!-- _header: 'Estrategia avanzada' -->

# Trabajar hacia atrás

**Pensar al revés:**
* Empezar desde el resultado deseado
* ¿Qué necesito para obtenerlo?
* Ir hacia atrás hasta los datos

**Ejemplo: Factorial**
* Resultado: n!
* ¿Qué necesito? n * (n-1)!
* ¿Y para (n-1)!? (n-1) * (n-2)!
* Caso base: 1! = 1

<!--
NOTAS DEL ORADOR:
- Útil para recursión y problemas matemáticos.
- "¿Qué tendría que haber pasado justo antes de terminar para que esto sea cierto?".
-->

---

<!-- _header: 'Tips' -->

# Consejos para planificar

**No te apresures:**
* Planificar ahorra tiempo después
* Detectar errores en papel es más fácil

**Usa papel:**
* Dibujar ayuda a pensar
* Diagramas, tablas, ejemplos

**Consulta recursos:**
* Algoritmos conocidos
* Patrones de diseño

<!--
NOTAS DEL ORADOR:
- La hoja en blanco no muerde.
- Dibujar estructuras de datos ayuda a visualizarlas.
-->

---

<!-- _class: inverse -->

# <!-- fit --> El plan es tu mapa
## Sin él, te perdés en el código

<!--
NOTAS DEL ORADOR:
- Cierre.
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

**Etapa 2: Concebir un Plan**
* Diseñar estrategia antes de programar
* Descomponer en subproblemas
* Identificar patrones conocidos

**Herramientas:**
* Pseudocódigo
* Diagramas de flujo
* Casos de prueba

**Próxima etapa:**
* Ejecutar el plan (programar)

<!--
NOTAS DEL ORADOR:
- Próxima clase: Por fin, ¡a programar! (Etapa 3).
-->

---

<!-- _class: centered -->

# ¿Preguntas?