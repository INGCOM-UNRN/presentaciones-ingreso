---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Método de Pólya - Parte 4/4' -->

# <!-- fit --> Método de Pólya
## Etapa 4: Verificar y Reflexionar
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 2 minutos
- Objetivo: Enseñar a mirar atrás y aprender de la solución.
- Gancho: "El programa corre y no da error. ¿Terminamos? No, recién empieza la parte donde nos volvemos mejores programadores."
-->

---

<!-- _class: inverse -->

# <!-- fit --> Etapa 4
## Examinar la Solución

<!--
NOTAS DEL ORADOR:
- También llamada "Looking Back" (Mirar hacia atrás).
- Es la etapa más descuidada por los estudiantes (y profesionales).
-->

---

<!-- _header: 'Objetivo' -->

# Más allá de "funciona"

**Verificar que la solución:**
* Es correcta
* Es completa
* Es óptima

**Buscar:**
* Oportunidades de mejora
* Posibilidades de generalización
* Lecciones aprendidas

<!--
NOTAS DEL ORADOR:
- La diferencia entre "funciona" y "es bueno".
- ¿Es frágil? ¿Se rompe si lo miro feo?
- ¿Es rápido? ¿Es legible?
-->

---

<!-- _header: 'Dimensiones' -->

# Corrección funcional

**Preguntas clave:**
* ¿Produce resultados correctos?
* ¿Maneja casos límite?
* ¿Es robusta ante entradas inesperadas?

**Testing exhaustivo:**
* Casos normales
* Casos especiales
* Casos extremos

<!--
NOTAS DEL ORADOR:
- Validación rigurosa.
- Ya hicimos algunos tests al ejecutar, ahora hacemos la auditoría final.
-->

---

<!-- _header: 'Dimensiones' -->

# Calidad del código

**Estilo:**
* ¿Sigue convenciones establecidas?
* ¿Es legible y mantenible?
* ¿Documentación clara?

**Diseño:**
* ¿Funciones con responsabilidad única?
* ¿Nombres descriptivos?
* ¿Buen manejo de errores?

<!--
NOTAS DEL ORADOR:
- Code Review (Revisión de código).
- Imagina que otro tiene que leer tu código mañana. O vos mismo en 6 meses.
- Refactorización: Mejorar la estructura sin cambiar el comportamiento.
-->

---

<!-- _header: 'Dimensiones' -->

# Eficiencia

**Complejidad:**
* ¿Es eficiente en tiempo?
* ¿Usa memoria apropiadamente?

**Optimización:**
* ¿Hay mejoras posibles?
* Sin sacrificar claridad

<!--
NOTAS DEL ORADOR:
- No obsesionarse con la micro-optimización prematura.
- Pero sí evitar ineficiencias obvias (ej: leer el mismo archivo 100 veces en un loop).
-->

---

<!-- _header: 'Dimensiones' -->

# Generalización

**Reutilización:**
* ¿Se puede extender?
* ¿Hay componentes reutilizables?
* ¿Sirve para problemas similares?

**Aprendizaje:**
* ¿Qué patrones identificaste?
* ¿Qué técnicas aplicaste?

<!--
NOTAS DEL ORADOR:
- ¿Resolví ESTE problema o resolví UNA CLASE de problemas?
- Abstracción: Hacer la solución más genérica.
-->

---

<!-- _header: 'Ejemplo - Testing' -->

# Testing exhaustivo: Encontrar máximo

```python
def test_exhaustivo_maximo():
    # Caso normal
    assert encontrar_maximo([3,7,2,9,1]) == 9
    
    # Un solo elemento
    assert encontrar_maximo([5]) == 5
    
    # Lista vacía
    assert encontrar_maximo([]) is None
    
    # Todos negativos
    assert encontrar_maximo([-5,-2,-8]) == -2
    
    print("✓ Todos los tests pasaron")
```

<!--
NOTAS DEL ORADOR:
- Repasar los tests.
- Asegurar que cubrimos "Edge Cases" (bordes).
-->

---

<!-- _header: 'Ejemplo - Testing' -->

# Más casos de prueba

```python
# Máximo al inicio
assert encontrar_maximo([9,3,2,1]) == 9

# Máximo al final
assert encontrar_maximo([1,2,3,9]) == 9

# Duplicados del máximo
assert encontrar_maximo([5,9,3,9,1]) == 9

# Con flotantes
assert encontrar_maximo([3.14,2.71,1.41]) == 3.14
```

<!--
NOTAS DEL ORADOR:
- ¿Qué pasa si hay dos máximos iguales?
- ¿Qué pasa si el máximo es el primero o el último? (Off-by-one errors).
-->

---

<!-- _header: 'Análisis' -->

# Complejidad del algoritmo

**Encontrar máximo:**
* Tiempo: O(n) - recorre lista una vez
* Espacio: O(1) - espacio constante

**¿Se puede mejorar?**
* No en tiempo (hay que revisar todos)
* Espacio ya es óptimo

**donde n = longitud de la lista**

<!--
NOTAS DEL ORADOR:
- Introducción muy suave a la complejidad algorítmica (Big O).
- No se puede encontrar el máximo sin mirar todos los elementos al menos una vez (a menos que esté ordenada).
-->

---

<!-- _header: 'Revisión estilo' -->

# Checklist de estilo

**En nuestro código:**
* ✅ Nombres descriptivos
* ✅ Docstring completo
* ✅ Validación de entrada
* ✅ Sin variables globales
* ✅ Responsabilidad única
* ✅ No usa print() para lógica
* ✅ Función pura (sin efectos secundarios)

<!--
NOTAS DEL ORADOR:
- Checklist mental para el alumno.
- Si cumple todo esto, es un código profesional.
-->

---

<!-- _header: 'Reflexión' -->

# Preguntas para reflexionar

**1. ¿Podría ser más simple?**
```python
# Alternativa con built-in
def encontrar_maximo_v2(lista):
    return max(lista) if lista else None
```

**Más corto, pero:**
* Menos educativo
* Menos control sobre lógica

<!--
NOTAS DEL ORADOR:
- A veces la mejor solución es no escribir código (usar built-ins).
- Pero para aprender, reinventar la rueda es útil.
-->

---

<!-- _header: 'Reflexión' -->

# ¿Qué aprendiste?

**Patrones identificados:**
* Inicializar con primer elemento
* Iterar sobre los restantes
* Actualizar en base a condición

**Reutilizable para:**
* Encontrar mínimo
* Encontrar cualquier extremo
* Buscar elemento con propiedad

<!--
NOTAS DEL ORADOR:
- Meta-cognición.
- Entender el patrón subyacente (Búsqueda Lineal).
-->

---

<!-- _header: 'Generalización' -->

# Generalizar la solución

```python
def encontrar_extremo(lista, comparador):
    """Generaliza para min o max.
    
    Args:
        lista: Lista de elementos
        comparador: Función de comparación
    """
    if not lista:
        return None
    
    extremo = lista[0]
    for elem in lista[1:]:
        if comparador(elem, extremo):
            extremo = elem
    return extremo
```

<!--
NOTAS DEL ORADOR:
- Ejemplo avanzado de generalización.
- Pasamos la función de comparación como argumento (High Order Functions).
- Esto es poderoso: la misma lógica sirve para min, max, o cualquier criterio raro.
-->

---

<!-- _header: 'Generalización' -->

# Usar la generalización

```python
import operator

# Encontrar máximo
maximo = encontrar_extremo(
    [3,7,2,9,1],
    operator.gt  # greater than
)

# Encontrar mínimo
minimo = encontrar_extremo(
    [3,7,2,9,1],
    operator.lt  # less than
)
```

<!--
NOTAS DEL ORADOR:
- Demostración de uso.
-->

---

<!-- _header: 'Importancia' -->

# La revisión es aprendizaje

**No es solo verificación:**
* Identificar patrones reutilizables
* Comprender por qué funciona
* Mejorar habilidades de programación

**Es oportunidad para:**
* Reflexionar sobre el proceso
* Documentar lecciones aprendidas
* Aplicar en problemas futuros

<!--
NOTAS DEL ORADOR:
- Si no revisás, no aprendés. Solo repetís.
-->

---

<!-- _header: 'Ejemplo completo' -->

# Aplicación: Validador de contraseñas

**Problema:**
* Validar contraseña con requisitos:
  * Mínimo 8 caracteres
  * Al menos una mayúscula
  * Al menos una minúscula
  * Al menos un dígito
  * Al menos un carácter especial

**Aplicamos las 4 etapas...**

<!--
NOTAS DEL ORADOR:
- Ejemplo integrador rápido para cerrar el ciclo Pólya.
-->

---

<!-- _header: 'Fase 1: Comprender' -->

# Comprender el problema

**Entrada:**
* Una cadena (contraseña)

**Salida:**
* bool (True si válida, False si no)

**Restricciones:**
* 5 condiciones simultáneas

**Casos:**
```
"Abc123!x" → True
"abc123!" → False (falta mayúscula)
"Abc!" → False (muy corta)
```

---

<!-- _header: 'Fase 2: Planificar' -->

# Plan de solución

**Estrategia:**
1. Verificar longitud >= 8
2. Inicializar banderas
3. Recorrer cada carácter
4. Actualizar banderas
5. Retornar si todas cumplidas

**Optimización:**
* Verificar longitud primero (falla rápido)

---

<!-- _header: 'Fase 3: Ejecutar' -->

# Implementación

```python
def validar_contrasena(pwd):
    if len(pwd) < 8:
        return False
    
    tiene_may = any(c.isupper() for c in pwd)
    tiene_min = any(c.islower() for c in pwd)
    tiene_dig = any(c.isdigit() for c in pwd)
    tiene_esp = any(c in "!@#$%^&*" for c in pwd)
    
    return tiene_may and tiene_min and \
           tiene_dig and tiene_esp
```

---

<!-- _header: 'Fase 4: Verificar' -->

# Testing completo

```python
def test_validar():
    assert validar_contrasena("Abc123!x") == True
    assert validar_contrasena("abc123!") == False
    assert validar_contrasena("ABC123!") == False
    assert validar_contrasena("Abc!") == False
    assert validar_contrasena("") == False
    assert validar_contrasena("A1!aaaaa") == True
    
    print("✓ Validador: tests OK")

test_validar()
```

---

<!-- _class: inverse -->

# <!-- fit --> El Método de Pólya
## Tu guía para cualquier problema

---

<!-- _header: 'Resumen completo' -->

# Las 4 etapas

**1. Comprender:**
* Entender entrada, salida, restricciones
* Casos especiales

**2. Planificar:**
* Diseñar estrategia
* Pseudocódigo y casos de prueba

**3. Ejecutar:**
* Implementar con disciplina
* Seguir el plan

**4. Verificar:**
* Testing exhaustivo
* Reflexionar y mejorar

<!--
NOTAS DEL ORADOR:
- Resumen final del módulo.
- Estas 4 etapas deben convertirse en un hábito inconsciente.
-->

---

<!-- _header: 'Beneficios' -->

# ¿Por qué usar este método?

**Reduce errores:**
* Detectarlos temprano es más barato

**Mejora código:**
* Pensado y probado

**Desarrolla habilidad:**
* Pensamiento algorítmico
* Resolución sistemática

**Aplicable a todo:**
* Cualquier problema de programación

---

<!-- _class: centered -->

# ¿Preguntas?