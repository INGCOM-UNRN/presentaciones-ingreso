---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Método de Pólya - Parte 3/4' -->

# <!-- fit --> Método de Pólya
## Etapa 3: Ejecutar el Plan
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 2 minutos
- Objetivo: Mostrar cómo traducir el plan a código real.
- Gancho: "Ahora sí, ¡a picar código! Pero con el mapa en la mano."
-->

---

<!-- _class: inverse -->

# <!-- fit --> Etapa 3
## Ejecutar el Plan

<!--
NOTAS DEL ORADOR:
- Transición: Llegamos a la parte que todos querían.
- Pero notan la diferencia: ya sabemos QUÉ vamos a escribir. Solo nos falta saber CÓMO escribirlo en Python.
-->

---

<!-- _header: 'Objetivo' -->

# Implementar la solución

**Traducir el plan a código:**
* Del pseudocódigo a Python
* Mantener la estructura lógica
* Prestar atención a sintaxis y semántica

**Con cuidado:**
* Documentar cuando sea necesario
* Seguir buenas prácticas
* Validar casos especiales

<!--
NOTAS DEL ORADOR:
- La metáfora de la traducción: El pseudocódigo es el guion, el código es la película.
- El programador actúa como traductor entre su pensamiento lógico y la máquina.
-->

---

<!-- _header: 'Principios' -->

# Traducción sistemática

**Paso a paso:**
* Convertir cada línea del pseudocódigo
* Mantener la estructura del plan
* No inventar cosas nuevas

**Comentar solo lo necesario:**
* Explicar el "por qué", no el "qué"
* El código debe ser autoexplicativo

<!--
NOTAS DEL ORADOR:
- Disciplina: Si el plan decía "sumar x", el código debe sumar x.
- Si se te ocurre una "mejora" brillante mientras codificás, ANOTALA, pero no la implementes ya. Terminá el plan original primero.
- Evitar "Feature Creep" (agregar cosas que no se pidieron).
-->

---

<!-- _header: 'Buenas prácticas' -->

# Al escribir código

**Estilo:**
* Seguir reglas de estilo (PEP 8)
* Nombres descriptivos de variables
* Funciones con un propósito claro

**Robustez:**
* Validar entradas
* Manejar casos excepcionales
* No asumir datos perfectos

<!--
NOTAS DEL ORADOR:
- Recordatorio de PEP 8 (vimos algo en fundamentos).
- Nombres de variables: `total` es mejor que `t`. `indice` es mejor que `i` (a veces).
-->

---

<!-- _header: 'Ejemplo' -->

# Implementación: Encontrar máximo

**Del pseudocódigo...**
```
función encontrar_maximo(lista):
    si lista está vacía:
        retornar Nada
    maximo_actual = lista[0]
    para cada elemento en lista[1:]:
        si elemento > maximo_actual:
            maximo_actual = elemento
    retornar maximo_actual
```

**...al código Python**

<!--
NOTAS DEL ORADOR:
- Mostrar el "antes".
- Pedir a los alumnos que imaginen cómo se ve en Python.
-->

---

<!-- _class: code -->
<!-- _header: 'Implementación' -->

# Código Python

```python
def encontrar_maximo(lista):
    """Encuentra el máximo en una lista.
    
    Args:
        lista: Lista de números
        
    Returns:
        El elemento máximo o None
    """
    # Validar lista vacía
    if not lista:
        return None
    
    maximo_actual = lista[0]
    
    for elemento in lista[1:]:
        if elemento > maximo_actual:
            maximo_actual = elemento
    
    return maximo_actual
```

<!--
NOTAS DEL ORADOR:
- Mostrar la correspondencia casi 1 a 1.
- Resaltar:
    - Docstring (no estaba en pseudocódigo, pero es buena práctica).
    - `if not lista:` es la forma Pythonica de `si lista vacía`.
    - Slicing `lista[1:]` para saltar el primero.
-->

---

<!-- _header: 'Detalles' -->

# Observaciones del código

**Docstring:**
* Describe propósito
* Parámetros y retorno
* Ejemplos si es complejo

**Validación:**
* Maneja caso de lista vacía
* Retorna None (no error)

**Lógica clara:**
* Sigue el plan exactamente
* Fácil de seguir

<!--
NOTAS DEL ORADOR:
- La legibilidad es clave.
- Cualquiera que lea esto entiende qué hace, incluso si no sabe mucho Python.
-->

---

<!-- _header: 'Verificación' -->

# Probar durante la implementación

```python
# Tests básicos
def test_encontrar_maximo():
    assert encontrar_maximo([3,7,2,9,1]) == 9
    assert encontrar_maximo([5]) == 5
    assert encontrar_maximo([]) is None
    assert encontrar_maximo([-3,-7,-2]) == -2
    print("Todas las pruebas pasaron")

test_encontrar_maximo()
```

**Probar temprano evita errores**

<!--
NOTAS DEL ORADOR:
- "Test Driven Development" (TDD) light.
- Escribir una pequeña prueba que use la función.
- `assert` es una herramienta simple para verificar verdades. Si falla, el programa explota (y eso es bueno ahora, no en producción).
-->

---

<!-- _header: 'Errores comunes' -->

# Errores al implementar

**Error 1: Inventar sobre la marcha**
* No seguir el plan
* Agregar lógica no pensada

**Error 2: Código descuidado**
* Nombres confusos (`x`, `tmp`, `a1`)
* Sin validaciones
* Sin documentación

**Error 3: No probar**
* Asumir que funciona
* No verificar casos límite

<!--
NOTAS DEL ORADOR:
- El programador "cowboy" vs el ingeniero.
- Improvisar lleva a código espagueti.
-->

---

<!-- _header: 'Otro ejemplo' -->

# Implementación: Validar contraseña

**Plan anterior:**
```
si longitud < 8: retornar Falso
si no tiene mayúscula: retornar Falso
si no tiene dígito: retornar Falso
retornar Verdadero
```

**Ahora en Python...**

<!--
NOTAS DEL ORADOR:
- Segundo ejemplo para reforzar.
- Lógica booleana.
-->

---

<!-- _class: code -->
<!-- _header: 'Implementación' -->

# Código: Validar contraseña

```python
def validar_contrasena(password):
    """Valida contraseña según criterios.
    
    Returns:
        bool: True si es válida
    """
    if len(password) < 8:
        return False
    
    if not any(c.isupper() for c in password):
        return False
    
    if not any(c.isdigit() for c in password):
        return False
    
    return True
```

<!--
NOTAS DEL ORADOR:
- Introducir `any()` como una herramienta poderosa de Python (si no la conocen, explicar que verifica si AL MENOS UNO cumple).
- Mostrar cómo el plan "si no tiene mayúscula" se traduce a `not any(...)`.
-->

---

<!-- _header: 'Implementación' -->

# Verificación

```python
# Tests
assert validar_contrasena("Hola1234") == True
assert validar_contrasena("hola1234") == False
assert validar_contrasena("Hola") == False
assert validar_contrasena("HolaMundo") == False

print("Contraseña: tests OK")
```

**Cada criterio probado**

<!--
NOTAS DEL ORADOR:
- Cobertura de pruebas: Probar casos positivos y negativos.
- Probar el caso borde (8 caracteres exactos, sin mayúscula, sin número).
-->

---

<!-- _header: 'Iteración' -->

# Desarrollo iterativo

**No todo a la vez:**
1. Implementar versión básica
2. Probar
3. Agregar características
4. Probar de nuevo

**Ejemplo:**
* Primero: función básica
* Después: validaciones
* Después: casos especiales
* Probar cada paso

<!--
NOTAS DEL ORADOR:
- No intentes escribir 100 líneas de código y luego ejecutar.
- Escribí 5 líneas, ejecutá. Otras 5, ejecutá.
- Feedback loop corto.
-->

---

<!-- _header: 'Debugging' -->

# Si algo no funciona

**Estrategia:**
1. Leer mensaje de error
2. Identificar línea del problema
3. Revisar lógica vs plan
4. Usar `print()` para depurar
5. Probar con casos simples

**No adivines:**
* Entender el error
* Corregir la causa, no el síntoma

<!--
NOTAS DEL ORADOR:
- Debugging es una habilidad científica. Hipótesis -> Experimento -> Conclusión.
- No cambiar código al azar ("Shotgun debugging").
-->

---

<!-- _header: 'Tips' -->

# Consejos al implementar

**Programá en sesiones:**
* Mejor varias sesiones cortas
* Descansar ayuda a pensar

**Revisa el plan:**
* Si te perdés, volver al plan
* El plan es tu guía

**Pide ayuda:**
* Si estás trabado 30+ minutos
* Explicar a otro ayuda a entender

<!--
NOTAS DEL ORADOR:
- Salud mental del programador.
- Pedir ayuda es de inteligentes, no de débiles.
-->

---

<!-- _class: inverse -->

# <!-- fit --> Implementar != Adivinar
## Seguí el plan con disciplina

<!--
NOTAS DEL ORADOR:
- Cierre.
- Disciplina > Inspiración.
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

**Etapa 3: Ejecutar el Plan**
* Traducir pseudocódigo a Python
* Seguir el plan sin inventar
* Aplicar buenas prácticas

**Durante implementación:**
* Validar entradas
* Documentar apropiadamente
* Probar cada paso

**Próxima etapa:**
* Verificar y reflexionar

<!--
NOTAS DEL ORADOR:
- Próxima clase: Ya anda. ¿Es bueno? (Etapa 4).
-->

---

<!-- _class: centered -->

# ¿Preguntas?