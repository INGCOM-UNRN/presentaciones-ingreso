---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Primeros Pasos - Parte 1/5' -->

# <!-- fit --> ¿Qué es un Algoritmo?
## Aprendé a pensar antes de programar
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 2 minutos
- Objetivo: Establecer la mentalidad correcta para todo el curso.
- Gancho: "¿Saben cuál es el error número 1 de los estudiantes de programación? Empezar a escribir código inmediatamente."

Esta es la primera presentación del curso y establece la mentalidad fundamental: pensar antes de programar. Muchos estudiantes quieren saltar directo al código, pero este slide establece que la programación empieza con el pensamiento algorítmico.

Comenzá preguntando: "¿Quién ya programó antes?" y luego "¿Quién planificó antes de escribir código?". La segunda pregunta suele tener menos manos levantadas, y ahí está la oportunidad de enseñar.

El mensaje central: la programación no es solo teclear, es resolver problemas de forma sistemática.
-->

---

<!-- _header: '¿Por qué es importante?' -->

# La verdad incómoda

**Problema común:**
* Abrir Python y escribir código directamente
* El código no funciona
* Perderse en medio del problema
* Pasar horas buscando errores

**La solución:**
* Planificar ANTES de programar

<!--
NOTAS DEL ORADOR:
- 5 minutos de planificación ahorran 1 hora de debugging.
- Escribir código es solo el 20% del trabajo. El 80% es pensar.

Este es el error más común en estudiantes principiantes: sentarse frente a la computadora y comenzar a escribir código sin planificación previa. Es como intentar armar un mueble sin leer las instrucciones.

La planificación no es perder tiempo, es ganar tiempo. Cinco minutos pensando pueden ahorrar horas de debugging.
-->

---

<!-- _header: 'Analogía' -->

# Como construir una casa

**Mal enfoque:**
* Comprar ladrillos y apilarlos sin pensar

**Buen enfoque:**
* Primero hacer un plano
* Después construir

<!--
NOTAS DEL ORADOR:
- Nadie construiría una casa sin planos.
- El algoritmo es el plano de tu software.

La analogía de la construcción es potente porque todos entienden que nadie construye sin planos. Del mismo modo, el algoritmo es el "plano" de tu programa.

Preguntá a los estudiantes: ¿Alguna vez intentaron armar algo complejo sin instrucciones? ¿Cómo salió?
-->

---

<!-- _class: inverse -->

# <!-- fit --> Programar = Planificar + Codificar

---

<!-- _header: 'Conceptos' -->

# ¿Qué es un algoritmo?

**Definición:**
* Secuencia de pasos precisos
* Resuelven un problema específico
* Como una receta de cocina

**Vocabulario clave:**
* **Entrada**: datos que necesitás
* **Proceso**: pasos a seguir
* **Salida**: resultado final

<!--
NOTAS DEL ORADOR:
- Definición de libro: Conjunto finito de instrucciones para resolver un problema.
- Modelo E-P-S (Entrada-Proceso-Salida).

Un algoritmo es fundamentalmente una receta. Así como una receta de cocina tiene ingredientes (entrada), instrucciones paso a paso (proceso), y un plato terminado (salida), un algoritmo computacional sigue la misma estructura.

La clave está en que cada paso debe ser tan preciso que una computadora pueda ejecutarlo sin ambigüedad.
-->

---

<!-- _header: 'Ejemplo 1' -->

# Receta de Panqueques

**Ingredientes (Entrada):**
* 2 huevos
* 1 taza de harina
* 1 taza de leche

**Pasos (Proceso):**
1. Batir los huevos
2. Agregar harina y leche
3. Mezclar hasta que esté suave
4. Calentar la sartén
5. Verter mezcla, cocinar 2 min/lado

<!--
NOTAS DEL ORADOR:
- Todos saben cocinar (o intentaron).
- Si alterás el orden (calentar sartén antes de tener huevos), falla.

Los panqueques son un ejemplo perfecto porque todos los conocen. Acá se ve claramente:
- ENTRADA: ingredientes específicos con cantidades
- PROCESO: pasos ordenados y secuenciales
- SALIDA implícita: panqueques listos

Preguntá: ¿Qué pasa si intercambiamos los pasos? ¿Qué pasa si vertemos la mezcla en la sartén fría? Esto muestra que el orden importa.

Esta es la misma estructura que tendrán todos sus programas, pero con datos en vez de ingredientes.
-->

---

<!-- _header: 'Ejemplo 2' -->

# Algoritmo: Promedio de 2 números

**Entrada:**
* Primer número
* Segundo número

**Proceso:**
1. Leer el primer número
2. Leer el segundo número
3. Sumar ambos números
4. Dividir la suma entre 2

**Salida:**
* El promedio

<!--
NOTAS DEL ORADOR:
- Ejemplo informático más simple posible.
- Notar la estructura E-P-S.

Este ejemplo es deliberadamente simple. Es importante que los estudiantes vean que incluso problemas triviales tienen esta estructura de entrada-proceso-salida.

Podés preguntarles: ¿Qué pasa si cambiamos "promedio" por "máximo"? Solo cambiaría el paso 4, pero la estructura se mantiene.
-->

---

<!-- _header: 'Características' -->

# Un BUEN algoritmo debe ser

**1. Preciso:**
* Cada paso super claro
* ❌ "Mezclar"
* ✅ "Mezclar con batidora 2 minutos"

**2. Finito:**
* Debe terminar en algún momento
* ❌ "Seguí cocinando"
* ✅ "Cocinar hasta dorado (2 min)"

<!--
NOTAS DEL ORADOR:
- Ambigüedad es el enemigo.
- Lazo infinito = programa colgado.
Este primer slide de características introduce PRECISO y FINITO. Son las dos más fundamentales:

**Preciso:** Cada paso debe ser tan claro que no haya interpretaciones múltiples. "Mezclar" deja muchas preguntas: ¿con qué? ¿cuánto tiempo? ¿qué tan rápido? En cambio, "Mezclar con batidora 2 minutos" no deja dudas.

**Finito:** Todo algoritmo debe tener un final. "Seguí cocinando" es un lazo infinito. En programación, los lazos infinitos son bugs comunes. Siempre debe haber una condición clara de terminación.

Preguntá: "¿Qué pasa si un programa nunca termina?" (se cuelga, consume recursos, frustra al usuario).
-->

---

<!-- _header: 'Características' -->

# Un BUEN algoritmo debe ser

**3. Efectivo:**
* Posible de realizar
* ❌ "Volar hasta la luna"
* ✅ "Caminar hasta la panadería"

**4. Ordenado:**
* Orden lógico de pasos
* ❌ "Servir, calentar, cortar"
* ✅ "Cortar, calentar, servir"

<!--
NOTAS DEL ORADOR:
- Las instrucciones deben ser ejecutables por quien las recibe (la computadora).
- El orden altera el producto.

El orden importa. Un algoritmo con los pasos correctos pero en orden incorrecto produce resultados incorrectos o imposibles.

Analogía humorística: "Ponerse los zapatos y luego las medias" vs "Ponerse las medias y luego los zapatos". Ambos tienen los mismos pasos, pero solo uno funciona.
-->

---

<!-- _header: 'Quiz' -->

# ¿Cuál es mejor?

**Opción A:**
1. Agarrar pan
2. Poner jamón
3. Fin

**Opción B:**
1. Agarrar 2 rebanadas de pan
2. Ponerlas sobre un plato
3. Colocar 2 fetas de jamón
4. Cubrir con la otra rebanada
5. Cortar por la mitad (opcional)

<!--
NOTAS DEL ORADOR:
- Ejercicio interactivo.
- La opción A es como hablamos entre humanos (asumimos contexto).
- La opción B es como hablamos a las máquinas (explícito).

Este es un ejercicio de pensamiento crítico. Dejá que los estudiantes debatan primero antes de revelar la respuesta.

La opción A tiene múltiples problemas de ambigüedad:
- ¿Cuántas rebanadas de pan? (¿1? ¿2?)
- ¿Cuánto jamón? (¿una feta? ¿todo el paquete?)
- "Poner jamón" ¿dónde? ¿sobre el pan? ¿al lado?

La opción B elimina toda ambigüedad con cantidades específicas y verbos precisos.

En programación, escribir código como la opción A resulta en errores. La computadora necesita especificidad absoluta.

Actividad recomendada: pedí a un voluntario que ejecute literalmente las instrucciones de A. Verán el caos que genera la ambigüedad.
-->

---

<!-- _class: inverse -->

# <!-- fit --> B es mejor
## Más preciso y claro

<!--
La opción A es ambigua: ¿Cuánto pan? ¿Cuánto jamón? ¿Dónde ponerlo? La opción B elimina todas las ambigüedades.

Esta es la diferencia entre un algoritmo vago y uno preciso. Las computadoras necesitan la versión B siempre.

Podés hacer la actividad: pedí a un voluntario que siga las instrucciones de A literalmente, y verán las dificultades.
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

* Algoritmo = receta de pasos
* Siempre tiene: entrada, proceso, salida
* Debe ser: preciso, finito, efectivo, ordenado
* Pensar antes de programar

**Próximo paso:**
* Las 5 Preguntas Mágicas

<!--
Este slide de resumen refuerza los conceptos clave. No avances demasiado rápido aquí; asegurate de que entendieron:

1. **Algoritmo = receta**: No es magia, es metodología
2. **Estructura E-P-S**: Entrada-Proceso-Salida (todas las soluciones tienen esta estructura)
3. **4 características**: Preciso, Finito, Efectivo, Ordenado (podés usar el acrónimo PFEO si ayuda)
4. **Mentalidad**: Pensar primero, codificar después

Preguntá: "¿Alguien puede dar un ejemplo de algoritmo de su vida diaria?" Validá cualquier respuesta que tenga pasos claros y ordenados.

La siguiente presentación introduce las 5 Preguntas Mágicas, que son la herramienta práctica para convertir problemas en algoritmos.
-->

---

<!-- _class: centered -->

# ¿Preguntas?

<!--
Momento de pausar y responder dudas. Algunas preguntas comunes y cómo responderlas:

**"¿Tengo que escribir algoritmos para todo?"**
Al principio sí, como práctica. Con experiencia, harás estos pasos mentalmente para problemas simples, pero siempre los escribirás para problemas complejos.

**"¿Un algoritmo es lo mismo que un programa?"**
No. El algoritmo es la solución abstracta (la idea). El programa es la implementación concreta en un lenguaje específico. Es como la diferencia entre la receta y el plato cocinado.

**"¿Por qué no empezamos directamente con Python?"**
Porque Python es solo una herramienta. Lo importante es aprender a pensar algorítmicamente. Una vez que sabés pensar bien, cualquier lenguaje es solo sintaxis.

**"¿Los programadores profesionales hacen esto?"**
Sí. Se llama "diseño antes de implementación" y es práctica estándar en la industria. Los mejores programadores son los mejores planificadores.

Recordales que en la próxima presentación van a aprender una herramienta concreta (las 5 Preguntas) para diseñar algoritmos sistemáticamente.
-->
