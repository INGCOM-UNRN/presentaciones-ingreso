---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Método de Pólya - Parte 1/4' -->

# <!-- fit --> Método de Pólya
## Etapa 1: Comprender el Problema
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 2 minutos
- Objetivo: Introducir el marco de trabajo general para la resolución de problemas.
- Gancho: "¿Alguna vez empezaron a escribir código y a los 20 minutos se dieron cuenta de que no sabían qué estaban resolviendo? Pólya viene a salvarnos."
-->

---

<!-- _header: 'Introducción' -->

# ¿Quién fue Pólya?

**George Pólya (1887-1985):**
* Matemático húngaro
* Libro: "Cómo resolverlo" (1945)
* Método sistemático para resolver problemas

**Aplicable a:**
* Matemáticas
* Programación
* Algoritmos

<!--
NOTAS DEL ORADOR:
- Contexto histórico breve.
- Aunque el libro es de matemáticas, es la "Biblia" de la resolución de problemas en computación.
- La programación ES resolución de problemas, el código es solo la herramienta.
-->

---

<!-- _header: 'Las 4 etapas' -->

# El Método de Pólya

**4 fases secuenciales:**

1. **Comprender** el problema
2. **Concebir** un plan
3. **Ejecutar** el plan
4. **Verificar** y reflexionar

**Hoy: Etapa 1**

<!--
NOTAS DEL ORADOR:
- Presentar el mapa completo.
- Énfasis en la secuencialidad: No podés planificar si no comprendiste. No podés ejecutar si no planificaste.
- Error común de novato: Saltar directo al paso 3 (Ejecutar/Codificar).
-->

---

<!-- _class: inverse -->

# <!-- fit --> Etapa 1
## Comprender el Problema

<!--
NOTAS DEL ORADOR:
- Transición: "¡Manos fuera del teclado!"
- En esta etapa NO se escribe código.
-->

---

<!-- _header: 'Objetivo' -->

# ¿Por qué es tan importante?

**Problema mal comprendido:**
* = Solución incorrecta
* No importa cuán elegante sea el código

**La comprensión es crucial:**
* Frecuentemente subestimada
* Base de todo lo que sigue
* Evita rehacer el trabajo

<!--
NOTAS DEL ORADOR:
- Analogía del arquitecto: Si el arquitecto no entiende que el cliente quería una casa de 2 pisos, no importa cuán bien ponga los ladrillos el albañil.
- "Medir dos veces, cortar una".
-->

---

<!-- _header: 'Preguntas clave' -->

# Identificación de datos

**¿Cuáles son los datos de entrada?**
* ¿Qué tipo de dato son?
* ¿Hay restricciones o limitaciones?
* ¿Hay casos especiales?
* ¿Valores límite a considerar?

<!--
NOTAS DEL ORADOR:
- Interrogar al problema.
- Ejemplo: Si el problema dice "Ingresar edad", ¿qué pasa si ponen -5? ¿O 200? ¿O "veinte"?
- Entender el dominio de los datos.
-->

---

<!-- _header: 'Preguntas clave' -->

# Definición de objetivos

**¿Cuál es el resultado esperado?**
* ¿En qué formato?
* ¿Qué relación hay entre entrada y salida?
* ¿Hay restricciones de tiempo o espacio?

<!--
NOTAS DEL ORADOR:
- Saber a dónde queremos llegar.
- ¿La salida es un número? ¿Un mensaje de texto? ¿Un archivo?
- Definir el criterio de éxito: "¿Cómo sé que terminé?".
-->

---

<!-- _header: 'Ejemplo' -->

# Problema: Promedio de calificaciones

**Enunciado:**
* Escribir un programa que calcule
* el promedio de calificaciones
* de un estudiante

**Aplicamos la fase de comprensión...**

<!--
NOTAS DEL ORADOR:
- Caso de estudio simple para ilustrar.
-->

---

<!-- _header: 'Ejemplo - Análisis' -->

# Datos de entrada

**¿Qué necesitamos?**
* Lista de calificaciones numéricas
* Tipo: `float` (decimales)
* Cantidad: variable (mínimo 1)
* Rango válido: 0.0 a 10.0

<!--
NOTAS DEL ORADOR:
- Desglosar explícitamente.
- Notar cómo definimos restricciones que no estaban explícitas en el enunciado corto (como el rango 0-10). Esto es parte de "comprender".
-->

---

<!-- _header: 'Ejemplo - Análisis' -->

# Resultado esperado

**¿Qué queremos obtener?**
* Un número (tipo: `float`)
* Representa el promedio
* Formato: dos decimales

**Fórmula:**
* promedio = suma / cantidad

<!--
NOTAS DEL ORADOR:
- Relación entrada-salida (la fórmula).
- Definir precisión (dos decimales).
-->

---

<!-- _header: 'Ejemplo - Análisis' -->

# Casos especiales

**Preguntas importantes:**
* ¿Qué hacer si la lista está vacía?
* ¿Cómo validar el rango [0.0, 10.0]?
* ¿Qué hacer con valores inválidos?

**Decisiones de diseño:**
* Definir comportamiento para cada caso

<!--
NOTAS DEL ORADOR:
- Edge cases (casos borde).
- División por cero si la lista está vacía.
- Un buen programador anticipa estos problemas ANTES de escribir código.
-->

---

<!-- _header: 'Especificación' -->

# Traducir a especificación

```python
"""
Función: calcular_promedio
Entrada: lista de números [0.0, 10.0]
Salida: número flotante (promedio)

Precondiciones:
  - lista no vacía
  - valores en rango válido

Poscondiciones:
  - retorna suma(califs) / cantidad
"""
```

<!--
NOTAS DEL ORADOR:
- Introducir el concepto de Contrato (Pre y Poscondiciones).
- Esto es lo que escribimos en papel o en el docstring antes de codificar la lógica.
-->

---

<!-- _header: 'Técnicas' -->

# Técnicas de comprensión

**1. Reformular con tus palabras**
* Explica el problema a otra persona

**2. Crear ejemplos concretos**
* Entrada y salida esperada

**3. Identificar similitudes**
* ¿Resolviste algo parecido antes?

**4. Dibujar diagramas**
* Cuando sea apropiado

<!--
NOTAS DEL ORADOR:
- Técnica del "Rubber Duck Debugging" (o explicarle al patito de goma).
- Dibujar siempre ayuda.
-->

---

<!-- _header: 'Ejercicio' -->

# Ejercicio: Búsqueda del máximo

**Problema:**
* Encontrar el mayor elemento
* en una lista de números

**Aplicá la fase de comprensión:**
* ¿Datos de entrada?
* ¿Resultado esperado?
* ¿Casos especiales?

<!--
NOTAS DEL ORADOR:
- Ejercicio rápido en clase.
- Pedir a los alumnos que NO escriban código, solo respondan las preguntas.
-->

---

<!-- _header: 'Ejercicio - Solución' -->

# Comprensión: Búsqueda del máximo

**Datos de entrada:**
* Lista de números (int o float)
* Cantidad: al menos 1 elemento
* Pueden ser negativos

**Resultado esperado:**
* El número más grande
* Mismo tipo que la entrada

<!--
NOTAS DEL ORADOR:
- Verificar si consideraron números negativos (un error común es inicializar el máximo en 0, lo cual falla si todos son negativos).
-->

---

<!-- _header: 'Ejercicio - Solución' -->

# Casos especiales

**Situaciones a considerar:**
* ¿Lista vacía? → Error o excepción
* ¿Un solo elemento? → Retornar ese
* ¿Todos iguales? → Retornar cualquiera
* ¿Todos negativos? → Funciona igual

<!--
NOTAS DEL ORADOR:
- Reforzar el caso de lista vacía.
- ¿Qué es el máximo de nada? (Indefinido).
-->

---

<!-- _class: inverse -->

# <!-- fit --> Comprender primero
## Programar después

<!--
NOTAS DEL ORADOR:
- Mantra de la clase.
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

**Etapa 1: Comprender**
* Crucial y frecuentemente ignorada
* Responder preguntas clave
* Identificar entrada, salida, casos especiales

**Técnicas:**
* Reformular el problema
* Crear ejemplos concretos
* Especificar formalmente

**Próxima etapa:**
* Concebir un plan

<!--
NOTAS DEL ORADOR:
- Cierre.
- Próxima clase: Ahora que entendemos el problema, ¿cómo diseñamos la solución?
-->

---

<!-- _class: centered -->

# ¿Preguntas?