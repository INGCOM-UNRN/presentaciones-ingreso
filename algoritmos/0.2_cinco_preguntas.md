---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Primeros Pasos - Parte 2/5' -->

# <!-- fit --> Las 5 Preguntas Mágicas
## Analizá cualquier problema
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 3 minutos
- Objetivo: Introducir una metodología sistemática para enfrentar problemas nuevos.
- Gancho: "Les voy a dar una herramienta que desbloquea cualquier problema de programación. Si saben responder estas 5 preguntas, ya tienen el 80% resuelto."

El objetivo es crear un hábito mental: siempre responder estas preguntas antes de tocar el teclado. Los estudiantes que internalizan este proceso escriben código más limpio, cometen menos errores y resuelven problemas más complejos.
-->

---

<!-- _class: inverse -->

# <!-- fit --> No te saltes este paso

<!--
NOTAS DEL ORADOR:
- La tentación de empezar a escribir código es fuerte.
- Resistir la tentación es lo que separa a los profesionales de los aficionados.
-->

---

<!-- _header: 'Las 5 Preguntas' -->

# Las 5 Preguntas Mágicas

**Antes de diseñar cualquier algoritmo:**

1. ¿Qué datos necesito? (Entrada)
2. ¿Qué resultado quiero? (Salida)
3. ¿Qué pasos debo seguir? (Proceso)
4. ¿Hay situaciones especiales? (Casos especiales)
5. ¿Necesito repetir algo? (Repeticiones)

<!--
NOTAS DEL ORADOR:
- Estas preguntas cubren: Datos, Lógica, Casos borde y Control de flujo.
- Memorícenlas. Úsenlas siempre.

**Enfatizá:** Este no es un checklist burocrático. Es una herramienta de pensamiento. Responder estas preguntas correctamente significa que ya tenés el 80% del problema resuelto.

Podés memorizarlas como: ENTRADA → SALIDA → PROCESO → ESPECIALES → REPETICIONES. El orden importa: siempre comenzamos entendiendo qué necesitamos y qué queremos producir antes de pensar en cómo hacerlo.

-->

---

<!-- _header: 'Origen' -->

# Basadas en el Método de Pólya

| Etapa de Pólya | Preguntas |
|:---------------|:----------|
| Comprender | 1, 2 y 4 |
| Planificar | 3 y 5 |
| Ejecutar | Diagrama/Pseudocódigo |
| Verificar | Pruebas de escritorio |

<!--
NOTAS DEL ORADOR:
- George Pólya, "How to Solve It" (1945).
- Es una metodología probada, no un invento caprichoso.

George Pólya fue un matemático húngaro que en 1945 publicó "How to Solve It", un libro fundamental sobre resolución de problemas. Su método de 4 etapas es la base de cómo se enseña programación en universidades de todo el mundo.

Las 5 Preguntas Mágicas son una adaptación práctica del método de Pólya específicamente para programación:
- Preguntas 1, 2 y 4 → **COMPRENDER** el problema
- Preguntas 3 y 5 → **PLANIFICAR** la solución
- Luego vendrán **EJECUTAR** (diagramas/pseudocódigo) y **VERIFICAR** (pruebas de escritorio)

Esta tabla muestra que no estamos inventando nada nuevo, solo aplicando décadas de investigación sobre resolución de problemas.
-->

---

<!-- _header: 'Ejemplo' -->

# Problema: Promedio de 3 números

**Enunciado:**
* Necesito un programa que calcule
* el promedio de 3 números

**Ahora aplicamos las 5 preguntas...**

<!--
NOTAS DEL ORADOR:
- Ejemplo simple para ilustrar la mecánica.

Este es el primer ejemplo completo. Es deliberadamente simple para que los estudiantes puedan seguir el razonamiento sin distraerse con complejidades.

Leé el enunciado en voz alta y preguntá: "¿Alguien puede resolver esto mentalmente?" Muchos dirán que sí. Entonces agregá: "Perfecto, pero ahora necesitamos explicárselo a una computadora que no sabe qué es un promedio."

Ese es el punto: nosotros entendemos intuitivamente, pero la computadora necesita instrucciones explícitas. Las 5 preguntas nos ayudan a descomponer lo intuitivo en pasos explícitos.
-->

---

<!-- _header: 'Pregunta 1' -->

# 1. ¿Qué datos necesito?

**Respuesta:**
* Tres números
* Pueden ser decimales (7.5, 8.2, 9.0)
* Los llamamos:
  * `numero1`
  * `numero2`
  * `numero3`

<!--
La primera pregunta establece las entradas. Es crucial ser específico sobre:

1. **Cantidad:** Tres números (no "algunos números" o "varios números")
2. **Tipo:** Pueden ser decimales (esto es importante: si usáramos división entera, el resultado sería incorrecto)
3. **Nombres:** Les damos identificadores (`numero1`, `numero2`, `numero3`)

**Preguntá:** "¿Por qué es importante saber que pueden ser decimales?" Respuesta: porque si asumimos enteros y alguien ingresa 7.5, el programa podría fallar o dar resultados incorrectos.

Nota sobre nomenclatura: usamos `numero1` en vez de `n1` porque la claridad es más importante que la brevedad. Los nombres descriptivos hacen código legible.
-->

---

<!-- _header: 'Pregunta 2' -->

# 2. ¿Qué resultado quiero?

**Respuesta:**
* El promedio de los tres números
* Es un número decimal
* Lo llamamos: `promedio`

**Fórmula:**
* promedio = (num1 + num2 + num3) / 3

<!--
La segunda pregunta define la salida. Acá identificamos:

1. **Qué es:** El promedio aritmético
2. **Tipo de dato:** Número decimal (float en Python)
3. **Nombre de variable:** `promedio`
4. **Fórmula matemática:** Suma dividida por cantidad

**Punto importante:** Mostrar la fórmula aquí es parte del análisis. Antes de programar, debemos saber la matemática involucrada.

Error común de principiantes: empezar a programar sin saber qué resultado esperan. Si no sabés qué querés obtener, ¿cómo sabrás si tu programa funciona?

Preguntá: "¿El promedio de 3, 4 y 5 es...?" (Respuesta: 4). Hacé un cálculo rápido para confirmar que todos entienden la fórmula básica.

-->

---

<!-- _header: 'Pregunta 3' -->

# 3. ¿Qué pasos debo seguir?

**Respuesta:**
1. Pedir el primer número
2. Pedir el segundo número
3. Pedir el tercer número
4. Sumar los tres números
5. Dividir la suma entre 3
6. Mostrar el resultado

<!--
Esta es la pregunta del PROCESO. Acá descomponemos el problema en pasos secuenciales y ordenados.

**Enfatizá el orden:** No podemos sumar antes de tener los números. No podemos dividir antes de sumar. Cada paso depende de los anteriores.

Observá que los pasos son en lenguaje natural, no código. Decimos "Pedir el primer número", no "input()". Esto es deliberado: el algoritmo es independiente del lenguaje de programación.

**Nivel de detalle:** Los pasos deben ser lo suficientemente específicos como para que sean claros, pero no tanto como para incluir detalles de implementación. "Pedir el primer número" es suficiente; no necesitamos decir "Mostrar mensaje 'Ingrese el primer número:' y leer desde teclado".

Podés preguntar: "¿Alguien ve algún paso que falte o sobre?" Esto fomenta el pensamiento crítico.
-->

---

<!-- _header: 'Pregunta 4' -->

# 4. ¿Hay situaciones especiales?

**Respuesta:**
* ¿Qué pasa si ingresan texto en vez de números?
* ¿Pueden ser números negativos?
* ¿Pueden ser cero?

**Para este ejercicio:**
* Asumimos que siempre ingresan números válidos
* Pueden ser negativos o cero

<!--
Esta pregunta introduce el concepto de validación de entrada. En ejercicios simples, asumimos entradas válidas. En programas reales, siempre hay que validar.

Es importante mencionar que "manejar casos especiales" diferencia un programa amateur de uno profesional.
-->

---

<!-- _header: 'Pregunta 5' -->

# 5. ¿Necesito repetir algo?

**Respuesta:**
* No hay repeticiones complejas
* Solo pedir 3 números (simple)
* Podríamos usar un lazo, pero no es necesario

<!--
La quinta pregunta identifica REPETICIONES (lazos/loops).

En este caso particular, la respuesta es "no" porque:
1. Solo son 3 números (cantidad fija y pequeña)
2. Escribir 3 líneas de código es más claro que un lazo
3. No hay lógica que se repita con variación

**Cuándo SÍ usar un lazo:**
- Cuando no sabemos cuántos elementos hay de antemano
- Cuando la cantidad es grande (ej: promedio de 100 números)
- Cuando la lógica es compleja y repetirla sería error-prone

**Técnica pedagógica:** Decí "Podrías hacerlo con un lazo de 3 iteraciones, pero sería usar un cañón para matar una mosca." Los estudiantes recuerdan las analogías visuales.

En el próximo ejemplo (número mayor de una lista) veremos un caso donde SÍ es necesario un lazo.
-->

---

<!-- _class: inverse -->

# <!-- fit --> Ahora ya sabés QUÉ hacer
## El próximo paso es CÓMO hacerlo

<!--
Este slide es un punto de inflexión. Responder las 5 preguntas te da el QUÉ (el análisis del problema). Los siguientes pasos (diagramas de flujo y pseudocódigo) te dan el CÓMO (la representación de la solución).

**Mensaje clave:** Si respondiste bien las 5 preguntas, el resto es traducción. La parte difícil del problema ya está resuelta.

Muchos estudiantes subestiman este análisis previo y piensan que la programación es solo escribir código. Acá reforzamos que el análisis ES la programación; el código es solo la última etapa.

Hacé una pausa dramática aquí antes de pasar al segundo ejemplo.
-->

---

<!-- _header: 'Otro ejemplo' -->

# Problema: Número mayor de una lista

**Enunciado:**
* Encontrar el número más grande
* de una lista de números

**Aplicá las 5 preguntas vos mismo...**

<!--
Pausa aquí y dales 2-3 minutos para que intenten responder las preguntas ellos mismos. Pueden trabajar en parejas.

Luego mostrarás las respuestas en las siguientes diapositivas. Esta práctica activa es crucial para el aprendizaje.
-->

---

<!-- _header: 'Respuesta 1' -->

# Número mayor - Pregunta 1

**1. ¿Qué datos necesito?**
* Una lista de números
* Pueden ser enteros o decimales
* Pueden ser positivos o negativos
* Debe tener al menos un número

<!--
Ahora analizamos las respuestas que (idealmente) los estudiantes ya intentaron responder.

**Entrada:** Una lista/colección de números de longitud desconocida.

Notá las especificaciones importantes:
- "Lista" implica colección/secuencia (no sabemos cuántos)
- "Pueden ser decimales" → necesitamos comparación que funcione con floats
- "Positivos o negativos" → importante para no asumir que el mayor es siempre positivo
- "Al menos uno" → esto es una **precondición**. Si la lista está vacía, el problema no tiene solución válida.

**Error común:** Asumir que los números son todos positivos y empezar el "mayor actual" en 0. Si todos son negativos, ¡el resultado sería 0 en vez del máximo real!

Preguntá: "¿Qué pasa si la lista está vacía?" para que reflexionen sobre casos límite.
-->

---

<!-- _header: 'Respuesta 2' -->

# Número mayor - Pregunta 2

**2. ¿Qué resultado quiero?**
* El número más grande de la lista
* Un solo número
* Del mismo tipo que los de entrada

<!--
**Salida:** Un único valor: el máximo de la lista.

Detalles importantes:
- "Un solo número" → no retornamos una lista, solo el máximo
- "Del mismo tipo que los de entrada" → si la lista tiene enteros, el resultado es entero; si tiene decimales, será decimal

**Pregunta reflexiva:** "¿Qué significa 'más grande'?" Para números, es obvio: 5 > 3. Pero esto introduce el concepto de **comparabilidad**. En el futuro trabajarán con objetos más complejos donde "más grande" puede significar cosas diferentes (ej: string más largo, fecha más reciente, etc.).

También podés preguntar: "¿Qué pasaría si necesitáramos los 3 números más grandes?" Eso cambiaría el problema completamente (requerría una estructura diferente). Por eso especificar bien la salida es crucial.
-->

---

<!-- _header: 'Respuesta 3' -->

# Número mayor - Pregunta 3

**3. ¿Qué pasos debo seguir?**
1. Tomar el primer número como "mayor"
2. Para cada número restante:
   * Si es mayor que el "mayor actual"
   * Actualizarlo como nuevo "mayor"
3. Mostrar el mayor encontrado

<!--
Este es un algoritmo clásico llamado "búsqueda lineal del máximo". La clave es inicializar con el primer elemento y luego comparar con el resto.

Error común: Inicializar con cero. ¿Qué pasa si todos los números son negativos? El máximo sería incorrecto.
-->

---

<!-- _header: 'Respuesta 4 y 5' -->

# Número mayor - Preguntas 4 y 5

**4. ¿Hay situaciones especiales?**
* ¿Lista vacía? (error)
* ¿Todos iguales? (retornar ese)
* ¿Todos negativos? (funciona igual)

**5. ¿Necesito repetir algo?**
* SÍ: recorrer todos los números
* Usar un lazo for o while

<!--
Aquí sí es claramente necesario un lazo porque no sabemos cuántos elementos tiene la lista de antemano.

Diferencia entre los ejemplos: en el promedio de 3 números sabíamos exactamente cuántos había. Aquí no, por lo que un lazo es esencial.
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

**Las 5 preguntas son tu mapa:**
1. ¿Qué datos necesito?
2. ¿Qué resultado quiero?
3. ¿Qué pasos debo seguir?
4. ¿Hay situaciones especiales?
5. ¿Necesito repetir algo?

**Siempre respondelas ANTES de programar**

<!--
Este resumen refuerza el mensaje central: las 5 preguntas no son opcionales, son la metodología.

**Práctica recomendada:** Durante el resto del curso, cada vez que introduzcas un nuevo problema, SIEMPRE empezá con las 5 preguntas antes de mostrar código. Los estudiantes aprenden por imitación; si vos siempre las usás, ellos las adoptarán.

**Analogía útil:** Las 5 preguntas son como un GPS. Podés intentar llegar a un lugar desconocido sin GPS (programar sin análisis previo), pero llegarás más rápido y con menos frustraciones si usás la herramienta.

**Consejo práctico:** Deciles que escriban las 5 preguntas en papel antes de tocar el teclado. Lo físico del acto ayuda a crear el hábito.

La siguiente presentación cubrirá diagramas de flujo, que es la forma de representar visualmente las respuestas a estas preguntas.
-->

---

<!-- _class: centered -->

# ¿Preguntas?

<!--
Preguntas frecuentes y cómo manejarlas:

**"¿Tengo que responder las 5 preguntas para TODO?"**
Al principio, sí. Con práctica, los problemas simples los resolverás mentalmente siguiendo esta estructura. Pero para problemas complejos, siempre será necesario hacerlo explícitamente.

**"¿En qué orden debo responder las preguntas?"**
Siempre en el orden dado: 1→2→3→4→5. Primero entendés qué necesitás y qué querés (1 y 2), luego planificás cómo lograrlo (3 y 5), y finalmente considerás excepciones (4).

**"¿Qué pasa si me equivoco en las respuestas?"**
¡Está bien! El objetivo de hacerlo en papel primero es que corregir papel es más rápido que corregir código. Si tus respuestas están mal, lo descubrirás rápido y podés ajustar antes de programar.

**"¿Los programadores reales hacen esto?"**
Sí, pero lo llaman "diseño de software", "análisis de requisitos", o "especificación de funciones". Las preguntas son las mismas, solo cambia el vocabulario.

**"¿Puedo cambiar el orden de las preguntas?"**
No para aprender. El orden es pedagógico y lógico. Una vez que domines el método, podés adaptarlo, pero primero aprendé la forma estándar.

Recordales que en la próxima clase verán cómo representar estas respuestas visualmente con diagramas de flujo.
-->
