---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Primeros Pasos - Parte 5/5' -->

# <!-- fit --> Pruebas de Escritorio
## Verificar antes de programar
Curso de Ingreso - Ingeniería en Computación

<!--
Esta es la **quinta y última presentación** de "Primeros Pasos". Completa el ciclo de diseño de algoritmos.

**Contexto en la secuencia:**
1. 0.1 - Qué es un algoritmo (concepto)
2. 0.2 - Las 5 preguntas mágicas (análisis)
3. 0.3 - Diagramas de flujo (diseño visual)
4. 0.4 - Pseudocódigo (diseño textual)
5. **0.5 - Pruebas de escritorio (verificación)** ← Estamos aquí

**Objetivo pedagógico central:**
Enseñar a los estudiantes a **verificar** que su algoritmo funciona ANTES de escribir código Python. Es la etapa de debugging preventivo.

**Problema que resuelve:**
Muchos estudiantes escriben pseudocódigo y asumen que funciona, luego programan y descubren errores lógicos que son difíciles de debuggear en código. Las pruebas de escritorio detectan estos errores en la etapa de diseño, cuando son fáciles de corregir.

**Analogía del curso completo:**
- Preguntas mágicas = Pensar qué cocinar
- Diagramas/Pseudocódigo = Escribir la receta
- **Pruebas de escritorio = Imaginar cocinar paso a paso para verificar que la receta funciona**
- Programar = Cocinar de verdad

**Gancho para captar atención:**
"¿Alguna vez siguieron una receta que parecía correcta, pero al final el plato salió mal? Las pruebas de escritorio son como leer la receta completa ANTES de cocinar, imaginando cada paso para detectar errores."

**Conceptos clave que se enseñan:**
1. Qué son las pruebas de escritorio
2. Por qué son importantes (ahorro de tiempo)
3. Cómo hacer una tabla de traza
4. Cómo ejecutar paso a paso
5. Cómo interpretar resultados

**Estructura de la presentación:**
- Definición y motivación (slides 1-3)
- Proceso de 4 pasos (slides 4-5)
- Ejemplo simple: Promedio de 2 números (slides 6-10)
- Ejemplo con decisión: Par o impar (slides 11-14)
- Ejemplo con lazo: Suma de 1 al 5 (slides 15-19)
- Consejos y errores comunes (slides 20-22)
- Cierre y práctica (slides 23-24)

**Mensaje motivacional inicial:**
"Las pruebas de escritorio pueden parecer lentas al principio, pero les ahorrarán HORAS de frustración después. Es la diferencia entre encontrar un error en 2 minutos revisando papel, versus 2 horas debuggeando código."

**Tono:** Práctico, enfatizando el ROI (retorno de inversión) de tiempo.

**Duración estimada:** 45-60 minutos (incluyendo práctica)
-->

---

<!-- _header: '¿Qué son?' -->

# Pruebas de Escritorio

**Definición:**
* Ejecutar el algoritmo "a mano"
* Como si fueras la computadora
* Paso a paso, con datos reales

**Analogía:**
Es como ser un actor ensayando una obra de teatro

Leés el guión y actuás cada escena antes del estreno

---

<!-- _header: '¿Qué significa cada parte?' -->

# Ejecutar "a mano"

**No usamos la computadora**
* Usamos papel y lápiz (o pizarra)
* Simulamos ser el procesador

**"Como si fueras la computadora"**
* La computadora es literal: hace EXACTAMENTE lo que le decís
* No asume, no adivina, no "interpreta"
* Vos también tenés que ser literal

---

<!-- _header: '¿Qué significa cada parte?' -->

# Paso a paso

**Una instrucción a la vez**
* Actualizás variables después de CADA operación
* No saltés pasos

**Con datos reales**
* No probás con "cualquier número"
* Elegís casos específicos (ej: 5 y 3, no "a y b")
* Usás números que revelen errores

---

<!-- _header: '¿Para qué sirven?' -->

# Beneficios de las Pruebas

**1. Encontrar errores ANTES de programar**
* Error en papel: 2 minutos corregir
* Error en código: 2 horas debuggear

**2. Verificar que la lógica funciona**
* ¿El resultado es correcto?
* ¿Termina el lazo?

**3. Entender mejor tu algoritmo**
* Al ejecutarlo, entendés qué hace realmente

---

<!-- _header: 'Dato importante' -->

# 70% de los bugs son lógicos

**Los errores más comunes NO son de sintaxis**

Son errores de **lógica** que las pruebas de escritorio detectan:
* Condiciones incorrectas (`<` vs `<=`)
* Lazos infinitos
* Variables mal inicializadas

**Pregunta:**
¿Preferís detectar un error en 5 min con papel, o en 2 horas peleando con Python?

---

<!-- _class: inverse -->

# <!-- fit --> Probar antes de programar
## Ahorra tiempo y frustraciones

---

<!-- _header: 'Comparación' -->

# Dos estudiantes, dos caminos

**Estudiante A (sin pruebas):**
1. Escribe pseudocódigo (10 min)
2. Programa en Python (15 min)
3. Ejecuta, no funciona
4. Debuggea durante 2 horas
5. **Total: 2h 25min, frustrado**

---

<!-- _header: 'Comparación' -->

# Dos estudiantes, dos caminos

**Estudiante B (con pruebas):**
1. Escribe pseudocódigo (10 min)
2. Hace pruebas de escritorio (10 min)
3. Detecta error, corrige (1 min)
4. Programa en Python (15 min)
5. **Total: 36 min, confiado**

**Diferencia: 109 minutos ahorrados**

---

<!-- _header: 'Principio clave' -->

# Detectar errores temprano

> "Detectar errores temprano es exponencialmente más barato que detectarlos tarde."

**Analogía arquitectónica:**
* Error en el plano → fácil de corregir
* Error con la casa medio construida → costoso

---

<!-- _header: 'Beneficios extra' -->

# Más que ahorrar tiempo

**Confianza:**
Sabés que tu algoritmo funciona antes de programar

**Comprensión profunda:**
Al simular la ejecución, entendés CÓMO funciona

**Prevención de lazos infinitos:**
En papel ves que el contador nunca cambia

---

<!-- _header: 'Cambio de mentalidad' -->

# De reactivo a proactivo

**Mentalidad vieja:**
"Programo y después veo si funciona"

**Mentalidad nueva:**
"Verifico que funciona y después programo"

> "Minutos de planificación te ahorran horas de debugging."

---

<!-- _class: inverse -->

# <!-- fit --> Los 4 Pasos
## Proceso para hacer pruebas de escritorio

---

<!-- _header: 'Paso 1' -->

# Elegir casos de prueba

**Casos normales:**
* Valores típicos del problema
* Números "fáciles" de calcular

**Casos especiales (bordes):**
* Cero
* Números negativos
* Valores límite

---

<!-- _header: 'Paso 2' -->

# Crear tabla de traza

**Columnas:**
* Una por cada variable
* Una para la salida/pantalla

**Filas:**
* Una por cada paso del algoritmo

| Paso | var1 | var2 | Salida |
|:-----|:-----|:-----|:-------|
| ... | ... | ... | ... |

---

<!-- _header: 'Paso 3' -->

# Ejecutar paso a paso

**Regla de oro: Sé un robot**
* Seguir cada instrucción literalmente
* Actualizar valores en la tabla
* No "pensar", solo ejecutar

**Importante:**
* Una instrucción a la vez
* Registrar cada cambio

---

<!-- _header: 'Paso 4' -->

# Verificar

**Preguntas clave:**
* ¿El resultado es correcto?
* ¿Tiene sentido matemático?
* ¿Probé suficientes casos?

**Si algo falla:**
* Revisar el pseudocódigo
* Corregir ANTES de programar

---

<!-- _class: inverse -->

# <!-- fit --> Ejemplo 1: Promedio
## Algoritmo lineal (sin decisiones)

---

<!-- _header: 'Ejemplo 1' -->

# Promedio de 2 números

**Pseudocódigo:**
```
LEER num1
LEER num2
suma ⟸ num1 + num2
promedio ⟸ suma / 2
MOSTRAR promedio
```

**Caso de prueba:** `num1 = 8`, `num2 = 12`

---

<!-- _header: 'Ejemplo 1' -->

# Tabla de traza

| Paso | num1 | num2 | suma | prom | Salida |
|:-----|:-----|:-----|:-----|:-----|:-------|
| LEER num1 | 8 | - | - | - | - |
| LEER num2 | 8 | 12 | - | - | - |
| suma ⟸ ... | 8 | 12 | 20 | - | - |
| prom ⟸ ... | 8 | 12 | 20 | 10 | - |
| MOSTRAR | 8 | 12 | 20 | 10 | "10" |

**Nota:** Los guiones `-` significan "no definido aún"

---

<!-- _header: 'Ejemplo 1' -->

# Verificación

**¿Es correcto?**
* 8 + 12 = 20 ✅
* 20 / 2 = 10 ✅
* Promedio de 8 y 12 es 10 ✅
* **¡Funciona!**

---

<!-- _header: 'Ejemplo 1' -->

# Probar más casos

**¿Funciona siempre?**

Un caso exitoso no es suficiente

| Caso | num1 | num2 | Resultado esperado |
|:-----|:-----|:-----|:-------------------|
| Negativos | -5 | 5 | 0 |
| Decimales | 7.5 | 8.5 | 8 |
| Iguales | 10 | 10 | 10 |

**Cobertura:**
* 1 caso → 20% confianza
* 3-4 casos variados → 80% confianza

---

<!-- _class: inverse -->

# <!-- fit --> Ejemplo 2: Par o Impar
## Algoritmo con decisión (SI-SINO)

---

<!-- _header: 'Ejemplo 2' -->

# Par o Impar

**Pseudocódigo:**
```
LEER numero
SI numero % 2 == 0 ENTONCES
    MOSTRAR "Es par"
SINO
    MOSTRAR "Es impar"
FIN_SI
```

**Operador %:** Devuelve el resto de la división
* 6 % 2 = 0 (par)
* 7 % 2 = 1 (impar)

---

<!-- _header: 'Ejemplo 2' -->

# ¿Cuántos casos probar?

**Regla para decisiones:**
Debés probar **AMBOS caminos**

* Un caso que entre al SI (número par)
* Un caso que entre al SINO (número impar)

Esto se llama **cobertura de ramas**

---

<!-- _header: 'Ejemplo 2' -->

# Caso 1: numero = 6

| Paso | numero | num%2 | Condición | Salida |
|:-----|:-------|:------|:----------|:-------|
| LEER | 6 | - | - | - |
| Evaluar | 6 | 0 | 0==0 → Verdadero | - |
| SI | 6 | 0 | Entra al SI | "Es par" |

**✅ Correcto: 6 es par**

---

<!-- _header: 'Ejemplo 2' -->

# Caso 2: numero = 7

| Paso | numero | num%2 | Condición | Salida |
|:-----|:-------|:------|:----------|:-------|
| LEER | 7 | - | - | - |
| Evaluar | 7 | 1 | 1==0 → Falso | - |
| SINO | 7 | 1 | Entra al SINO | "Es impar" |

**✅ Correcto: 7 es impar**

---

<!-- _header: 'Ejemplo 2' -->

# Comparación de ambos casos

| Aspecto | Caso 1 (6) | Caso 2 (7) |
|:--------|:-----------|:-----------|
| num % 2 | 0 | 1 |
| Condición | Verdadero | Falso |
| Rama | SI | SINO |
| Salida | "Es par" | "Es impar" |

**Cobertura completa:**
* ✅ Rama SI probada
* ✅ Rama SINO probada

---

<!-- _class: inverse -->

# <!-- fit --> Ejemplo 3: Suma con lazo
## Algoritmo con MIENTRAS

---

<!-- _header: 'Ejemplo 3' -->

# Suma de 1 al 5 (con lazo)

**Pseudocódigo:**
```
suma ⟸ 0
i ⟸ 1
MIENTRAS i <= 5 HACER
    suma ⟸ suma + i
    i ⟸ i + 1
FIN_MIENTRAS
MOSTRAR suma
```

**Los lazos son donde MÁS errores ocurren**

---

<!-- _header: 'Ejemplo 3' -->

# Análisis del algoritmo

**Variables:**
* `suma`: Acumulador (guarda el total)
* `i`: Contador (va de 1 a 5)

**Predicción:**
* i=1: suma = 0+1 = 1
* i=2: suma = 1+2 = 3
* i=3: suma = 3+3 = 6
* i=4: suma = 6+4 = 10
* i=5: suma = 10+5 = **15**

---

<!-- _header: 'Ejemplo 3' -->

# Estructura de tabla para lazos

**La tabla necesita:**
1. Filas de inicialización
2. Filas de evaluación de condición
3. Filas del cuerpo del lazo
4. Repetir hasta que salga

**Columnas:**
* Variables (suma, i)
* Condición (i <= 5)
* Acción (Entra/Vuelve/Sale)

---

<!-- _class: compact -->
<!-- _header: 'Ejemplo 3' -->

# Tabla de traza del lazo

| Paso | i | suma | i<=5 | Acción |
|:-----|:--|:-----|:-----|:-------|
| Inicializar | - | 0 | - | - |
| Inicializar | 1 | 0 | - | - |
| Evaluar | 1 | 0 | ✓ | Entra |
| suma = | 1 | 1 | ✓ | 0+1 |
| i = | 2 | 1 | - | 1+1 |
| Evaluar | 2 | 1 | ✓ | Vuelve |
| suma = | 2 | 3 | ✓ | 1+2 |
| i = | 3 | 3 | - | 2+1 |

---

<!-- _header: 'Ejemplo 3' -->

# Lectura de la tabla (parte 1)

**Filas 1-2: Inicialización**
* suma ⟸ 0
* i ⟸ 1

**Fila 3: Primera evaluación**
* ¿1 <= 5? → Verdadero (✓)
* Acción: Entra al lazo

**Filas 4-5: Primera iteración**
* suma = 0 + 1 = 1
* i = 1 + 1 = 2

---

<!-- _class: compact -->
<!-- _header: 'Ejemplo 3' -->

# Tabla de traza del lazo (cont.)

| Paso | i | suma | i<=5 | Acción |
|:-----|:--|:-----|:-----|:-------|
| Evaluar | 3 | 3 | ✓ | Vuelve |
| suma = | 3 | 6 | ✓ | 3+3 |
| i = | 4 | 6 | - | 3+1 |
| Evaluar | 4 | 6 | ✓ | Vuelve |
| suma = | 4 | 10 | ✓ | 6+4 |
| i = | 5 | 10 | - | 4+1 |
| Evaluar | 5 | 10 | ✓ | Vuelve |
| suma = | 5 | 15 | ✓ | 10+5 |
| i = | 6 | 15 | - | 5+1 |
| Evaluar | 6 | 15 | ✗ | Sale |

---

<!-- _header: 'Ejemplo 3' -->

# ¿Por qué sale del lazo?

**Última iteración (i=5):**
* ¿5 <= 5? → Verdadero (entra)
* suma = 10 + 5 = 15
* i = 5 + 1 = 6

**Intento de otra iteración:**
* ¿6 <= 5? → **Falso** (✗)
* Acción: **Sale del lazo**

El lazo termina correctamente

---

<!-- _header: 'Ejemplo 3' -->

# Verificación del lazo

**¿Es correcto?**
* 1 + 2 + 3 + 4 + 5 = 15 ✅
* El lazo se ejecutó 5 veces ✅
* El lazo terminó (i=6) ✅
* **¡Funciona!**

**Observación:**
Cuando sale del lazo, i vale 6 (límite + 1)

Esto es normal y esperado

---

<!-- _class: inverse -->

# <!-- fit --> Errores Comunes
## Lo que las pruebas detectan

---

<!-- _header: 'Errores comunes' -->

# Error 1: Lazo infinito

**Causa:**
Olvidar incrementar el contador

```
MIENTRAS i <= 5 HACER
    suma ⟸ suma + i
    # ¡FALTA! i ⟸ i + 1
```

**En la tabla se ve:**
i=1 en TODAS las filas → nunca termina

---

<!-- _header: 'Errores comunes' -->

# Error 2: Off-by-one

**Causa:**
Ejecutar una vez de más o de menos

```
MIENTRAS i < 5 HACER  # Debería ser <=
```

**En la tabla se ve:**
Solo 4 iteraciones en vez de 5

**Tip:** `<` vs `<=` es crítico

---

<!-- _header: 'Errores comunes' -->

# Error 3: Variables no inicializadas

**Causa:**
Usar variable antes de asignarle valor

```
# ¡FALTA! suma ⟸ 0
MIENTRAS i <= 5 HACER
    suma ⟸ suma + i  # ¿Cuánto vale suma?
```

**En la tabla se ve:**
suma tiene valor "basura" o indefinido

---

<!-- _class: inverse -->

# <!-- fit --> Elegir Buenos Casos
## Casos normales y casos borde

---

<!-- _header: 'Casos de prueba' -->

# Casos normales

**Valores típicos del problema:**
* Números "fáciles" de calcular
* Situaciones esperadas
* Lo que el usuario usaría normalmente

**Ejemplo:**
Para un promedio: num1=8, num2=12

---

<!-- _header: 'Casos de prueba' -->

# Casos especiales (bordes)

**Donde viven los bugs:**
* Cero
* Números negativos
* Valores muy grandes
* Listas vacías
* Primer/último elemento

**Ejemplo:**
¿Qué pasa si el usuario ingresa 0?

---

<!-- _header: 'Tips' -->

# Consejos para pruebas

**Sé metódico:**
* No saltees pasos
* Actualizá TODAS las variables

**Usá lápiz y papel:**
* Es más fácil que hacerlo mental
* Podés tachar y corregir

**Probá múltiples casos:**
* Un caso no es suficiente
* Especialmente para decisiones y lazos

---

<!-- _class: inverse -->

# <!-- fit --> Traducción a Python
## Del pseudocódigo al código real

---

<!-- _header: 'Comparación' -->

# Pseudocódigo → Python

**Pseudocódigo:**
```
LEER num1
LEER num2
promedio ⟸ (num1 + num2) / 2
MOSTRAR promedio
```

**Python:**
```python
num1 = float(input("Número 1: "))
num2 = float(input("Número 2: "))
promedio = (num1 + num2) / 2
print(f"Promedio: {promedio}")
```

---

<!-- _header: 'Equivalencias' -->

# Tabla de conversión

| Pseudocódigo | Python |
|:-------------|:-------|
| `LEER x` | `x = input()` |
| `MOSTRAR x` | `print(x)` |
| `x ⟸ 5` | `x = 5` |
| `SI ... ENTONCES` | `if ...:` |
| `SINO` | `else:` |
| `MIENTRAS` | `while ...:` |
| `PARA` | `for ... in range():` |

---

<!-- _header: 'Ventaja' -->

# Si probaste antes...

**La traducción es directa:**

El pseudocódigo ya está verificado, solo hay que traducir sintaxis

**Errores de Python son de SINTAXIS, no de LÓGICA**

Mucho más fáciles de arreglar

---

<!-- _class: inverse -->

# <!-- fit --> Resumen
## Lo que aprendimos hoy

---

<!-- _header: 'Resumen' -->

# Pruebas de escritorio

**¿Qué son?**
Ejecutar el algoritmo a mano, paso a paso

**¿Cómo se hacen?**
1. Elegir casos de prueba
2. Crear tabla de traza
3. Ejecutar paso a paso
4. Verificar resultados

---

<!-- _header: 'Resumen' -->

# Beneficios

**Detectar errores ANTES de programar**
* Lazos infinitos
* Off-by-one
* Variables no inicializadas

**Entender mejor la lógica**
* Al ejecutar, comprendés cómo funciona

**Ahorrar tiempo**
* 5 min de prueba vs 2 horas de debugging

---

<!-- _header: 'Próximo paso' -->

# Ahora te toca a vos

**El flujo completo:**
1. Diseñar pseudocódigo
2. Hacer pruebas de escritorio
3. Corregir si hay errores
4. Traducir a Python
5. Ejecutar con confianza

---

<!-- _class: centered -->

# ¿Preguntas?