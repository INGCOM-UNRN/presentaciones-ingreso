---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Primeros Pasos - Parte 6' -->

# <!-- fit --> Patrones Comunes
## Recetas algorítmicas que aparecen siempre
Curso de Ingreso - Ingeniería en Computación

<!--
Esta presentación introduce los **patrones algorítmicos fundamentales** que todo programador debe conocer.

**Contexto en la secuencia:**
1. 0.1 - Qué es un algoritmo (concepto)
2. 0.2 - Las 5 preguntas mágicas (análisis)
3. 0.3 - Diagramas de flujo (diseño visual)
4. 0.4 - Pseudocódigo (diseño textual)
5. 0.5 - Pruebas de escritorio (verificación)
6. **0.6 - Patrones comunes (recetas reutilizables)** ← Estamos aquí

**Objetivo pedagógico central:**
Enseñar a reconocer y aplicar patrones algorítmicos básicos que se repiten constantemente en programación. Estos patrones son como "piezas de Lego" que se pueden combinar para resolver problemas más complejos.

**Gancho para captar atención:**
"¿Sabían que el 90% de los problemas de programación se resuelven combinando solo 5 patrones básicos? Hoy van a aprender esas 5 recetas mágicas."

**Duración estimada:** 30-40 minutos
-->

---

<!-- _header: '¿Qué son los patrones?' -->

# Recetas Reutilizables

**Patrón algorítmico:**
* Solución probada a un problema común
* Como una receta de cocina
* Se adapta a distintas situaciones

**¿Por qué aprenderlos?**
* No empezás desde cero
* Código más ordenado
* Menos errores

<!--
**Analogía de la cocina:**

Cuando aprendés a cocinar, primero aprendés técnicas básicas:
- Saltear verduras
- Hacer una salsa blanca
- Preparar una masa base

Con esas técnicas podés hacer miles de platos diferentes.

En programación es igual:
- Acumulador → sumar, multiplicar, concatenar
- Contador → contar elementos
- Bandera → detectar si algo pasó

Con estos patrones resolvés la mayoría de los problemas.

**Cita:**
"Los buenos programadores no reinventan la rueda. Reconocen patrones y los aplican."
-->

---

<!-- _class: inverse -->

# <!-- fit --> Patrón 1: Acumulador
## Juntar valores en una variable

---

<!-- _header: 'Acumulador - ¿Qué es?' -->

# El Acumulador

**Definición:**
Una variable que va "juntando" valores

**Analogía:**
Es como contar monedas en una alcancía

Vas sacando una por una y las vas sumando al total que ya tenías

<!--
**Concepto clave:**
El acumulador es una variable que mantiene un "total parcial" que se actualiza en cada iteración del lazo.

La variable "arrastra" el valor anterior y le suma el nuevo.
-->

---

<!-- _header: 'Acumulador - ¿Para qué sirve?' -->

# Usos del Acumulador

**Sirve para:**
* Sumar números (total de ventas)
* Multiplicar (factorial)
* Concatenar texto (armar oraciones)
* Promedios (suma / cantidad)

**Clave:**
Mantiene un "total parcial" que se actualiza en cada vuelta del lazo

<!--
**Ejemplos reales:**
- Sumar precios de un carrito de compras
- Calcular el factorial de un número
- Armar una cadena de texto letra por letra
- Acumular puntaje en un juego
-->

---

<!-- _header: 'Acumulador - Estructura' -->

# Estructura Básica

```
acumulador ⟸ valor_inicial

PARA cada elemento HACER
    acumulador ⟸ acumulador + elemento
FIN_PARA
```

**Valores iniciales:**
* Para suma: empezar en **0**
* Para producto: empezar en **1**
* Para texto: empezar en **""**

<!--
**Error común:**
Inicializar el acumulador DENTRO del lazo → se reinicia en cada iteración y perdés el total.

**¿Por qué 1 para producto?**
Porque cualquier número multiplicado por 1 da el mismo número. Si empezás en 0, el resultado siempre será 0.
-->

---

<!-- _header: 'Acumulador - Ejemplo' -->

# Ejemplo: Suma de 1 al 5

**Pseudocódigo:**
```
suma ⟸ 0
PARA i DESDE 1 HASTA 5 HACER
    suma ⟸ suma + i
FIN_PARA
MOSTRAR suma
```

<!--
**Observar:**
- suma empieza en 0 (valor inicial para suma)
- En cada vuelta se actualiza: suma = suma + i
- El patrón es siempre: `acumulador = acumulador + nuevo_valor`
-->

---

<!-- _header: 'Acumulador - Ejecución' -->

# Traza del Ejemplo

| Iteración | i | suma (antes) | suma (después) |
|:----------|:--|:-------------|:---------------|
| 1 | 1 | 0 | 0 + 1 = **1** |
| 2 | 2 | 1 | 1 + 2 = **3** |
| 3 | 3 | 3 | 3 + 3 = **6** |
| 4 | 4 | 6 | 6 + 4 = **10** |
| 5 | 5 | 10 | 10 + 5 = **15** |

**Resultado:** 15 ✅

<!--
**Python equivalente:**
```python
suma = 0
for i in range(1, 6):
    suma = suma + i
print(suma)
```
-->

---

<!-- _class: inverse -->

# <!-- fit --> Patrón 2: Contador
## Contar cuántas veces pasa algo

---

<!-- _header: 'Contador - ¿Qué es?' -->

# El Contador

**Definición:**
Una variable que cuenta cuántas veces ocurre algo

**Analogía:**
Es como el contador de personas en la entrada de un local

Cada vez que entra alguien, suma 1. No importa quién sea.

<!--
**Diferencia con acumulador:**
- Acumulador: suma VALORES diferentes (1, 2, 3...)
- Contador: suma siempre 1 (cuenta CUÁNTOS)
-->

---

<!-- _header: 'Contador - ¿Para qué sirve?' -->

# Usos del Contador

**Sirve para:**
* Contar cuántos números son positivos
* Contar cuántos alumnos aprobaron
* Estadísticas (cuántos pares, impares)
* Contar intentos del usuario

**Clave:**
Solo incrementa cuando SE CUMPLE la condición

<!--
**Ejemplos reales:**
- Contar cuántos productos cuestan más de $1000
- Contar votos a favor y en contra
- Contar errores en una validación
-->

---

<!-- _header: 'Contador - Estructura' -->

# Estructura Básica

```
contador ⟸ 0

PARA cada elemento HACER
    SI condicion ENTONCES
        contador ⟸ contador + 1
    FIN_SI
FIN_PARA
```

**Valor inicial:** Siempre **0**

**Incremento:** Siempre **+1**

<!--
**Observar:**
- El contador SIEMPRE empieza en 0
- El incremento SIEMPRE es 1 (no sumamos valores, contamos)
- La condición determina CUÁNDO contar
-->

---

<!-- _header: 'Contador - Ejemplo' -->

# Ejemplo: Contar positivos

**Datos:** -3, 5, 2, -1, 0, 8

**Pseudocódigo:**
```
contador ⟸ 0
PARA cada numero HACER
    SI numero > 0 ENTONCES
        contador ⟸ contador + 1
    FIN_SI
FIN_PARA
MOSTRAR contador
```

<!--
**Observar:**
- Solo cuenta cuando numero > 0
- El 0 NO es positivo, no se cuenta
-->

---

<!-- _header: 'Contador - Ejecución' -->

# Traza del Ejemplo

| Número | ¿Es > 0? | Acción | contador |
|:-------|:---------|:-------|:---------|
| -3 | No | No cuenta | 0 |
| 5 | Sí | Cuenta | **1** |
| 2 | Sí | Cuenta | **2** |
| -1 | No | No cuenta | 2 |
| 0 | No | No cuenta | 2 |
| 8 | Sí | Cuenta | **3** |

**Resultado:** 3 positivos ✅

<!--
**Python equivalente:**
```python
numeros = [-3, 5, 2, -1, 0, 8]
contador = 0
for num in numeros:
    if num > 0:
        contador += 1
print(contador)
```
-->

---

<!-- _class: inverse -->

# <!-- fit --> Patrón 3: Máximo/Mínimo
## Encontrar el más grande o más chico

---

<!-- _header: 'Máximo - ¿Qué es?' -->

# Buscar el Máximo

**Definición:**
Encontrar el número más grande de un conjunto

**Analogía:**
Es como buscar al más alto en una fila

Agarrás al primero como referencia y vas comparando

<!--
**También aplica para mínimo:**
Solo cambiás la comparación de > a <
-->

---

<!-- _header: 'Máximo - ¿Para qué sirve?' -->

# Usos del Máximo/Mínimo

**Sirve para:**
* Encontrar la nota más alta
* Encontrar el precio más bajo
* Buscar el jugador con más puntos
* Determinar temperatura extrema

**Clave:**
Empezar con el **primer valor**, no con 0

<!--
**Error común:**
Empezar con maximo = 0
- ¿Qué pasa si todos los números son negativos?
- Ejemplo: -5, -3, -8 → maximo quedaría en 0 (¡incorrecto!)
-->

---

<!-- _header: 'Máximo - Estructura' -->

# Estructura Básica

```
maximo ⟸ primer_numero

PARA cada numero (desde el segundo) HACER
    SI numero > maximo ENTONCES
        maximo ⟸ numero
    FIN_SI
FIN_PARA
```

**Para mínimo:** Cambiar `>` por `<`

<!--
**Valor inicial:**
Usar el primer elemento como candidato inicial.
Si encontrás uno mejor, lo reemplazás.
-->

---

<!-- _header: 'Máximo - Ejemplo' -->

# Ejemplo: Encontrar el máximo

**Datos:** 3, 7, 2, 9, 1

**Pseudocódigo:**
```
maximo ⟸ 3  # Primer número
PARA cada numero en [7, 2, 9, 1] HACER
    SI numero > maximo ENTONCES
        maximo ⟸ numero
    FIN_SI
FIN_PARA
MOSTRAR maximo
```

<!--
**Observar:**
- maximo empieza con el primer valor (3)
- Solo se actualiza cuando encontramos uno mayor
-->

---

<!-- _header: 'Máximo - Ejecución' -->

# Traza del Ejemplo

| Número | ¿Es > maximo? | Acción | maximo |
|:-------|:--------------|:-------|:-------|
| (inicio) | - | Inicializar | **3** |
| 7 | 7 > 3? Sí | Reemplaza | **7** |
| 2 | 2 > 7? No | Mantiene | 7 |
| 9 | 9 > 7? Sí | Reemplaza | **9** |
| 1 | 1 > 9? No | Mantiene | 9 |

**Resultado:** 9 ✅

<!--
**Python equivalente:**
```python
numeros = [3, 7, 2, 9, 1]
maximo = numeros[0]
for num in numeros[1:]:
    if num > maximo:
        maximo = num
print(maximo)
```
-->

---

<!-- _class: inverse -->

# <!-- fit --> Patrón 4: Bandera (Flag)
## Recordar si algo ocurrió

---

<!-- _header: 'Bandera - ¿Qué es?' -->

# La Bandera (Flag)

**Definición:**
Una variable booleana que "recuerda" si algo pasó

**Analogía:**
Es como una alarma de incendio

Empieza "apagada". Si detecta humo, se "enciende" y ya no se apaga.

<!--
**Valores posibles:**
- Verdadero (True) → Sí pasó
- Falso (False) → No pasó
-->

---

<!-- _header: 'Bandera - ¿Para qué sirve?' -->

# Usos de la Bandera

**Sirve para:**
* ¿Hay algún número negativo?
* ¿Existe el elemento buscado?
* ¿Hubo algún error?
* Responder preguntas Sí/No

**Clave:**
Una vez que cambia a Verdadero, permanece así

<!--
**Característica importante:**
No importa cuántas veces más se cumpla la condición, la bandera ya está en Verdadero.
-->

---

<!-- _header: 'Bandera - Estructura' -->

# Estructura Básica

```
bandera ⟸ Falso

PARA cada elemento HACER
    SI condicion ENTONCES
        bandera ⟸ Verdadero
    FIN_SI
FIN_PARA
```

**Valor inicial:** Siempre **Falso**

**Cambio:** Solo a **Verdadero** (nunca vuelve a Falso)

<!--
**Optimización:**
Una vez que encontramos lo que buscamos, podemos salir del lazo con `break`.
-->

---

<!-- _header: 'Bandera - Ejemplo' -->

# Ejemplo: ¿Hay algún negativo?

**Datos:** 5, 2, -3, 8, 1

**Pseudocódigo:**
```
hay_negativo ⟸ Falso
PARA cada numero HACER
    SI numero < 0 ENTONCES
        hay_negativo ⟸ Verdadero
    FIN_SI
FIN_PARA
```

<!--
**Observar:**
- Empieza en Falso (no encontré ninguno todavía)
- Cuando encuentra -3, cambia a Verdadero
- Ya no importa qué pase después
-->

---

<!-- _header: 'Bandera - Ejecución' -->

# Traza del Ejemplo

| Número | ¿Es < 0? | hay_negativo |
|:-------|:---------|:-------------|
| 5 | No | Falso |
| 2 | No | Falso |
| -3 | **Sí** | **Verdadero** |
| 8 | No | Verdadero |
| 1 | No | Verdadero |

**Resultado:** "Hay al menos un negativo" ✅

<!--
**Python equivalente:**
```python
numeros = [5, 2, -3, 8, 1]
hay_negativo = False
for num in numeros:
    if num < 0:
        hay_negativo = True
        break
print(hay_negativo)
```
-->

---

<!-- _class: inverse -->

# <!-- fit --> Patrón 5: Validación
## Pedir datos hasta que sean correctos

---

<!-- _header: 'Validación - ¿Qué es?' -->

# Validación de Entrada

**Definición:**
Seguir pidiendo un dato hasta que sea válido

**Analogía:**
Es como un guardia de seguridad

No te deja pasar hasta que muestres credencial válida

<!--
**Importancia:**
Los usuarios cometen errores. Un buen programa debe detectarlos y dar otra oportunidad.
-->

---

<!-- _header: 'Validación - ¿Para qué sirve?' -->

# Usos de la Validación

**Sirve para:**
* Asegurar que la edad esté entre 0 y 120
* Verificar que la opción del menú sea válida
* Pedir contraseña correcta
* Evitar errores por datos incorrectos

**Clave:**
Dar **feedback claro** al usuario sobre qué está mal

<!--
**Experiencia de usuario:**
El mensaje de error debe explicar QUÉ se espera, no solo decir "Error".
-->

---

<!-- _header: 'Validación - Estructura' -->

# Estructura Básica

```
REPETIR
    MOSTRAR "Ingrese dato:"
    LEER dato
    
    SI dato es inválido ENTONCES
        MOSTRAR "Error, intente de nuevo"
    FIN_SI
HASTA QUE dato sea válido
```

**Termina cuando:** El dato cumple las condiciones

<!--
**Variante con MIENTRAS:**
```
LEER dato
MIENTRAS dato es inválido HACER
    MOSTRAR "Error"
    LEER dato
FIN_MIENTRAS
```
-->

---

<!-- _header: 'Validación - Ejemplo' -->

# Ejemplo: Validar edad

**Problema:** Pedir edad entre 1 y 120

**Pseudocódigo:**
```
REPETIR
    MOSTRAR "Ingrese edad (1-120):"
    LEER edad
    SI edad < 1 O edad > 120 ENTONCES
        MOSTRAR "Edad inválida"
    FIN_SI
HASTA QUE edad >= 1 Y edad <= 120

MOSTRAR "Edad válida:", edad
```

<!--
**El lazo termina cuando:**
edad >= 1 Y edad <= 120 es Verdadero
-->

---

<!-- _header: 'Validación - Ejecución' -->

# Traza del Ejemplo

| Intento | Entrada | ¿Es válida? | Acción |
|:--------|:--------|:------------|:-------|
| 1 | 150 | No (> 120) | "Edad inválida" |
| 2 | -5 | No (< 1) | "Edad inválida" |
| 3 | 25 | **Sí** | Sale del lazo |

**Resultado:** "Edad válida: 25" ✅

<!--
**Python equivalente:**
```python
while True:
    edad = int(input("Ingrese edad (1-120): "))
    if 1 <= edad <= 120:
        break
    print("Edad inválida, intente de nuevo")
print(f"Edad válida: {edad}")
```
-->

---

<!-- _header: 'Resumen visual' -->

# Los 5 Patrones

| Patrón | Uso | Inicialización |
|:-------|:----|:---------------|
| **Acumulador** | Sumar/multiplicar | 0 (suma) o 1 (producto) |
| **Contador** | Contar elementos | 0 |
| **Máximo/Mínimo** | Encontrar extremo | Primer elemento |
| **Bandera** | ¿Pasó algo? | Falso |
| **Validación** | Entrada correcta | Pedir hasta válido |

<!--
**Tip:**
Cuando te enfrentes a un problema, preguntate:
- ¿Necesito juntar valores? → Acumulador
- ¿Necesito contar cuántos? → Contador
- ¿Necesito el mayor/menor? → Máximo/Mínimo
- ¿Necesito saber si algo pasó? → Bandera
- ¿Necesito datos correctos? → Validación

La mayoría de los problemas se resuelven combinando estos patrones.
-->

---

<!-- _header: 'Combinando patrones' -->

# Ejemplo combinado

**Problema:** Leer números hasta que se ingrese 0.
Mostrar la suma, el promedio y cuántos son positivos.

**Patrones usados:**
* Acumulador (suma)
* Contador (cantidad, positivos)
* Validación implícita (lazo hasta 0)

<!--
**Análisis:**
1. Necesitamos sumar → Acumulador
2. Necesitamos contar total → Contador
3. Necesitamos contar positivos → Contador con condición
4. Promedio = suma / cantidad

Este problema combina 3 patrones en un solo algoritmo.
-->

---

<!-- _header: 'Ejemplo combinado' -->

# Solución

```
suma ⟸ 0
cantidad ⟸ 0
positivos ⟸ 0

LEER numero
MIENTRAS numero != 0 HACER
    suma ⟸ suma + numero        # Acumulador
    cantidad ⟸ cantidad + 1     # Contador total
    SI numero > 0 ENTONCES
        positivos ⟸ positivos + 1  # Contador cond.
    FIN_SI
    LEER numero
FIN_MIENTRAS

promedio ⟸ suma / cantidad
MOSTRAR "Suma:", suma
MOSTRAR "Promedio:", promedio
MOSTRAR "Positivos:", positivos
```

<!--
**Observar:**
- 3 patrones trabajando juntos
- Cada variable tiene su rol específico
- El lazo termina cuando numero = 0

**Cuidado:**
¿Qué pasa si el usuario ingresa 0 de entrada?
→ cantidad = 0 → división por cero
→ Habría que agregar validación
-->

---

<!-- _header: 'Práctica' -->

# Para recordar

**Antes de programar, identificá:**
1. ¿Qué patrón necesito?
2. ¿Cómo lo inicializo?
3. ¿Cuándo lo actualizo?
4. ¿Qué muestro al final?

**Los patrones son tu caja de herramientas.**
Cuanto mejor los conozcas, más fácil será programar.

<!--
**Consejo final:**
No memorices código, entendé la LÓGICA detrás de cada patrón.

Si entendés que el acumulador "arrastra" un total parcial, podés aplicarlo a cualquier situación: sumar precios, calcular promedio, concatenar palabras, etc.

**Próximo paso:**
Practicar estos patrones con ejercicios hasta que sean automáticos.
-->

---

<!-- _class: inverse -->

# <!-- fit --> ¡Patrones aprendidos!
## La base para resolver cualquier problema

---

<!-- _header: 'Conexión con lo aprendido' -->

# Proceso completo

**1. Las 5 preguntas** → Entender el problema

**2. Diagrama de flujo** → Diseñar visualmente

**3. Pseudocódigo** → Escribir la lógica

**4. Pruebas de escritorio** → Verificar

**5. Patrones** → Reconocer soluciones conocidas

**6. Código Python** → Implementar

<!--
**Los patrones aceleran el paso 3:**
En vez de pensar "¿cómo sumo números?", reconocés "esto es un acumulador" y aplicás la receta.

**Analogía final:**
Un chef experto no piensa "¿cómo hago una salsa?" porque ya tiene las técnicas internalizadas. Vos vas a llegar a ese punto con los patrones.
-->

---

<!-- _class: centered -->

# ¿Preguntas?
