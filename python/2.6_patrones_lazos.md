---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Control de Flujo - Parte 6/6' -->

# <!-- fit --> Patrones de Lazos
## Recetas comunes para resolver problemas
Curso de Ingreso - Ingeniería en Computación

<!-- 
NOTAS DEL ORADOR:
- Duración estimada: 3 minutos
- Objetivo: Consolidar el conocimiento de lazos aplicándolos a problemas reales.
- Gancho: "¿Alguna vez se sintieron perdidos frente a una hoja en blanco? Los patrones son como piezas de Lego que ya saben cómo encajar."
-->

---

<!-- _header: '¿Qué son patrones?' -->

# Recetas reutilizables

**Patrón:**
* Solución común a problema recurrente
* Como una receta de cocina
* Se adapta a situaciones similares

**Ventaja:**
* No empezás desde cero
* Código más limpio
* Menos errores

<!--
NOTAS DEL ORADOR:
- En programación no reinventamos la rueda cada vez.
- Un patrón es un esquema mental que te dice "esto se resuelve así".
-->

---

<!-- _header: 'Patrón 1' -->

# Acumulador

**Problema:** Sumar, multiplicar, concatenar

**Estructura:**
```python
acumulador = valor_inicial
for elemento in secuencia:
    acumulador = acumulador operador elemento
```

**Ejemplo - Suma:**
```python
suma = 0  # Inicializar
for numero in [1, 2, 3, 4, 5]:
    suma += numero
print(suma)  # 15
```

<!--
NOTAS DEL ORADOR:
- Es el patrón más básico.
- El nombre `acumulador` o `suma` es lo de menos, lo importante es la lógica de "traer lo anterior y sumarle lo nuevo".
-->

---

<!-- _header: 'Acumulador' -->

# Variantes comunes

**Producto:**
```python
producto = 1  # Importante: 1, no 0
for numero in [2, 3, 4]:
    producto *= numero
# 24
```

**Concatenar:**
```python
resultado = ""
for palabra in ["Hola", "Mundo"]:
    resultado += palabra + " "
# "Hola Mundo "
```

<!--
NOTAS DEL ORADOR:
- ¡Atención al valor inicial!
- Si inicializo un producto en 0, el resultado siempre será 0.
- Si inicializo una suma en 1, el resultado tendrá un error de +1.
-->

---

<!-- _header: 'Patrón 2' -->

# Contador

**Problema:** Contar elementos que cumplen condición

**Estructura:**
```python
contador = 0
for elemento in secuencia:
    if condicion:
        contador += 1
```

**Ejemplo:**
```python
numeros = [1, 2, 3, 4, 5, 6]
pares = 0
for num in numeros:
    if num % 2 == 0:
        pares += 1
print(f"Pares: {pares}")  # 3
```

<!--
NOTAS DEL ORADOR:
- Es un acumulador especial donde el "operando" siempre es 1.
- Útil para estadísticas.
-->

---

<!-- _header: 'Patrón 3' -->

# Bandera (Flag)

**Problema:** Detectar si algo ocurrió

**Estructura:**
```python
bandera = False
for elemento in secuencia:
    if condicion:
        bandera = True
        break  # Opcional
```

**Ejemplo:**
```python
numeros = [1, 3, 5, 8, 9]
tiene_par = False
for num in numeros:
    if num % 2 == 0:
        tiene_par = True
        break
print(f"¿Tiene par? {tiene_par}")  # True
```

<!--
NOTAS DEL ORADOR:
- Responde a preguntas de Sí/No.
- El `break` es fundamental para no trabajar de más. Si ya encontré un par, no necesito mirar el resto de la lista.
-->

---

<!-- _header: 'Patrón 4' -->

# Búsqueda

**Problema:** Encontrar elemento

**Estructura:**
```python
encontrado = None  # o False
for elemento in secuencia:
    if condicion:
        encontrado = elemento
        break
```

**Ejemplo:**
```python
nombres = ["Ana", "Juan", "María"]
buscado = None
for nombre in nombres:
    if nombre.startswith("M"):
        buscado = nombre
        break
print(buscado)  # María
```

<!--
NOTAS DEL ORADOR:
- Similar a la bandera, pero guardamos el objeto en lugar de solo `True`.
- Usar `None` como valor inicial indica "no lo encontré todavía".
-->

---

<!-- _header: 'Patrón 5' -->

# Máximo/Mínimo

**Problema:** Encontrar el mayor o menor

**Estructura:**
```python
maximo = secuencia[0]  # Primer elemento
for elemento in secuencia[1:]:
    if elemento > maximo:
        maximo = elemento
```

**Ejemplo:**
```python
numeros = [3, 7, 2, 9, 1]
maximo = numeros[0]
for num in numeros[1:]:
    if num > maximo:
        maximo = num
print(maximo)  # 9
```

<!--
NOTAS DEL ORADOR:
- ERROR COMÚN: Inicializar `maximo = 0`. ¿Qué pasa si todos los números son negativos?
- FORMA CORRECTA: Inicializar con el primer elemento de la lista.
-->

---

<!-- _header: 'Traza: Búsqueda de Máximo' -->

# Ejecución paso a paso

**Lista:** `[3, 7, 2, 9, 1]`

| Paso | num | maximo | ¿num > max? | Acción |
|:-----|:----|:-------|:------------|:-------|
| Inicio | - | 3 | - | maximo = 3 |
| 1 | 7 | 3 | 7 > 3 (Sí) | maximo = 7 |
| 2 | 2 | 7 | 2 > 7 (No) | - |
| 3 | 9 | 7 | 9 > 7 (Sí) | maximo = 9 |
| 4 | 1 | 9 | 1 > 9 (No) | - |
| Fin | - | 9 | - | Print 9 |

<!--
NOTAS DEL ORADOR:
- Esta tabla muestra cómo evoluciona la variable `maximo`.
- Notar cómo `maximo` solo cambia cuando encontramos un valor superior.
- Es crucial entender que la variable mantiene su valor hasta que la pisamos.
-->

---

<!-- _header: 'Patrón 6' -->

# Validación

**Problema:** Verificar todos cumplen condición

**Estructura:**
```python
todos_validos = True
for elemento in secuencia:
    if not condicion:
        todos_validos = False
        break
```

**Ejemplo:**
```python
numeros = [2, 4, 6, 8]
todos_pares = True
for num in numeros:
    if num % 2 != 0:
        todos_pares = False
        break
print(todos_pares)  # True
```

<!--
NOTAS DEL ORADOR:
- Es el inverso de la Bandera.
- Empezamos siendo optimistas (`True`) y al primer error nos volvemos pesimistas (`False`).
-->

---

<!-- _header: 'Patrón 7' -->

# Filtrado

**Problema:** Seleccionar elementos que cumplen

**Estructura:**
```python
resultado = []
for elemento in secuencia:
    if condicion:
        resultado.append(elemento)
```

**Ejemplo:**
```python
numeros = [1, 2, 3, 4, 5, 6]
pares = []
for num in numeros:
    if num % 2 == 0:
        pares.append(num)
print(pares)  # [2, 4, 6]
```

<!--
NOTAS DEL ORADOR:
- Creamos una lista nueva que es un subconjunto de la original.
-->

---

<!-- _header: 'Patrón 8' -->

# Transformación

**Problema:** Modificar cada elemento

**Estructura:**
```python
resultado = []
for elemento in secuencia:
    nuevo = transformacion(elemento)
    resultado.append(nuevo)
```

**Ejemplo:**
```python
numeros = [1, 2, 3, 4, 5]
cuadrados = []
for num in numeros:
    cuadrados.append(num ** 2)
print(cuadrados)  # [1, 4, 9, 16, 25]
```

<!--
NOTAS DEL ORADOR:
- La lista resultante tiene el mismo tamaño que la original, pero los datos cambiaron.
-->

---

<!-- _header: 'Patrón 9' -->

# Validación con intentos

**Problema:** Limitar intentos de entrada

```python
MAX_INTENTOS = 3
intentos = 0
valido = False

while intentos < MAX_INTENTOS and not valido:
    entrada = input("Ingrese (s/n): ")
    intentos += 1
    
    if entrada in ['s', 'n']:
        valido = True
    else:
        print(f"Inválido. Quedan {MAX_INTENTOS - intentos}")

if valido:
    print("Entrada aceptada")
else:
    print("Demasiados intentos")
```

<!--
NOTAS DEL ORADOR:
- Patrón de seguridad común en logins.
-->

---

<!-- _header: 'Patrón 10' -->

# Menú interactivo

```python
opciones = {
    '1': 'Opción A',
    '2': 'Opción B',
    '3': 'Salir'
}

while True:
    print("\n=== MENÚ ===")
    for clave, desc in opciones.items():
        print(f"{clave}. {desc}")
    
    opcion = input("Elige: ")
    
    if opcion == '3':
        break
    elif opcion in opciones:
        print(f"Ejecutando {opciones[opcion]}")
    else:
        print("Opción inválida")
```

---

<!-- _header: 'Combinando patrones' -->

# Suma de pares positivos

```python
# Combina: contador, acumulador, filtrado
numeros = [-2, 3, 4, -5, 6, 8, -1]

suma_pares_positivos = 0  # Acumulador
cantidad = 0              # Contador

for num in numeros:
    if num > 0 and num % 2 == 0:  # Filtrado
        suma_pares_positivos += num
        cantidad += 1

print(f"Suma: {suma_pares_positivos}")
print(f"Cantidad: {cantidad}")
```

<!--
NOTAS DEL ORADOR:
- En la vida real, los patrones se mezclan.
-->

---

<!-- _header: 'Ejercicio integrador' -->

# Analizador de texto

**Crea un programa que:**
1. Pida una frase
2. Cuente:
   * Total de caracteres
   * Vocales
   * Consonantes
   * Espacios
3. Muestre estadísticas

<!--
NOTAS DEL ORADOR:
- Dejar 10 minutos para este ejercicio.
-->

---

<!-- _header: 'Ejercicio - Solución' -->

# Posible solución

```python
frase = input("Ingrese una frase: ")

total = len(frase)
vocales = 0
consonantes = 0
espacios = 0

for caracter in frase.lower():
    if caracter in "aeiou":
        vocales += 1
    elif caracter.isalpha():
        consonantes += 1
    elif caracter == " ":
        espacios += 1

print(f"Total: {total}")
print(f"Vocales: {vocales}")
print(f"Consonantes: {consonantes}")
print(f"Espacios: {espacios}")
```

---

<!-- _header: 'Mejores prácticas' -->

# Consejos para lazos

**1. Nombres descriptivos:**
```python
for estudiante in estudiantes:  # Claro
for i in estudiantes:           # Confuso
```

**2. Mantener lazos simples:**
* Un propósito por lazo
* Máximo 2 niveles de anidación

**3. Usar funciones built-in:**
```python
suma = sum(numeros)      # En vez de lazo
maximo = max(numeros)    # En vez de lazo
```

<!--
NOTAS DEL ORADOR:
- "Simple is better than complex" (Zen de Python).
- Si Python ya tiene una función que lo hace (`sum`, `max`), usala. Es más rápida y menos propensa a errores.
-->

---

<!-- _class: inverse -->

# <!-- fit --> ¡Control de flujo completo!
## Ya podés crear programas complejos

---

<!-- _header: 'Resumen completo' -->

# Lo que aprendiste

**Condicionales:**
* if, elif, else
* Operador ternario
* Condiciones anidadas

**Lazos:**
* while - mientras condición
* for - para cada elemento
* break, continue

**Patrones:**
* Acumulador, contador, bandera
* Búsqueda, validación, filtrado
* Máximo/mínimo, transformación

---

<!-- _header: 'Habilidades adquiridas' -->

# Ahora podés

**Crear:**
* Menús interactivos
* Validaciones de entrada
* Juegos simples
* Procesamiento de datos

**Resolver:**
* Problemas repetitivos
* Búsquedas en listas
* Cálculos iterativos
* Análisis de texto

---

<!-- _header: 'Próximo capítulo' -->

# ¿Qué sigue?

**Estructuras de datos:**
* Listas más profundo
* Tuplas
* Diccionarios
* Conjuntos

**Te permitirá:**
* Organizar datos complejos
* Acceso eficiente
* Modelar problemas reales

<!--
NOTAS DEL ORADOR:
- Transición a la siguiente unidad.
-->

---

<!-- _class: centered -->

# ¡Felicitaciones!
## Control de flujo completado

---

<!-- _class: centered -->

# ¿Preguntas?