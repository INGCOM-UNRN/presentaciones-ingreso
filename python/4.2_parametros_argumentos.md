---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Funciones - Parte 2/6' -->

# <!-- fit --> Parámetros y Argumentos
## Funciones que reciben datos
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 3 minutos
- Objetivo: Entender cómo pasar información a las funciones para hacerlas dinámicas.
- Gancho: "Nuestra licuadora del ejemplo anterior siempre hacía el mismo licuado. Ahora vamos a aprender a ponerle distintas frutas."
-->

---

<!-- _header: 'Funciones flexibles' -->

# Recibir información

**Sin parámetros:**
```python
def saludar():
    print("¡Hola!")

saludar()  # Siempre igual
```

**Con parámetros:**
```python
def saludar(nombre):
    print(f"¡Hola, {nombre}!")

saludar("Ana")    # ¡Hola, Ana!
saludar("Bruno")  # ¡Hola, Bruno!
```

<!--
NOTAS DEL ORADOR:
- Mostrar la diferencia lado a lado.
- La función sin parámetros es rígida, "hardcoded".
- La función con parámetros es una plantilla reutilizable.
- Preguntar: "¿Cuántos saludos distintos podemos generar con la segunda función?" (Infinitos).
-->

---

<!-- _header: 'Vocabulario' -->

# Parámetro vs Argumento

**Parámetro:**
* En la definición
* La "casilla" para el dato
* Como un molde

**Argumento:**
* En la llamada
* El dato real
* Lo que va en el molde

```python
def saludar(nombre):  # ← parámetro
    print(f"Hola, {nombre}")

saludar("Ana")  # ← argumento
```

<!--
NOTAS DEL ORADOR:
- Esta distinción es técnica pero importante para comunicarse con precisión.
- Analogía: El "Parámetro" es la variable vacía en la fórmula (x en f(x)). El "Argumento" es el valor que le damos (5 en f(5)).
- Mnemotecnia:
    - **P**arámetro -> **P**laceholder (Marcador de posición).
    - **A**rgumento -> **A**ctual value (Valor actual).
-->

---

<!-- _header: 'Múltiples parámetros' -->

# Recibir varios datos

```python
def presentar(nombre, edad, ciudad):
    """Presenta a una persona."""
    print(f"Te presento a {nombre}")
    print(f"  → {edad} años")
    print(f"  → Vive en {ciudad}")

presentar("Ana", 20, "Buenos Aires")
presentar("Bruno", 22, "Córdoba")
```

**Orden de parámetros: separados por comas**

<!--
NOTAS DEL ORADOR:
- Podemos tener tantos parámetros como queramos, pero...
- Buenas prácticas: Si tenés más de 5 o 6, quizás tu función hace demasiadas cosas.
- El orden es CRUCIAL aquí (a menos que usemos keywords, que veremos luego).
-->

---

<!-- _class: inverse -->

# <!-- fit --> Tipos de Argumentos
## Posicionales y con nombre

<!--
NOTAS DEL ORADOR:
- Transición: Hasta ahora confiamos en el orden. ¿Qué pasa si nos equivocamos?
-->

---

<!-- _header: 'Argumentos posicionales' -->

# El orden importa

```python
def restar(a, b):
    """Resta b de a."""
    return a - b

print(restar(10, 3))  # 10 - 3 = 7
print(restar(3, 10))  # 3 - 10 = -7
```

**Diferente orden → Diferente resultado**

<!--
NOTAS DEL ORADOR:
- "Posicional" significa que Python decide qué valor va a qué variable basándose puramente en la posición (1º con 1º, 2º con 2º).
- En operaciones no conmutativas (resta, división), esto cambia el resultado.
-->

---

<!-- _header: 'Problema del orden' -->

# Confusión con muchos parámetros

**❌ Difícil de entender:**
```python
def describir_mascota(nombre, tipo, edad):
    print(f"{nombre} es un {tipo} de {edad} años")

# ¿Cuál es cuál?
describir_mascota("Firulais", "perro", 5)

# Si te equivocás en el orden...
describir_mascota("perro", 5, "Firulais")
# perro es un 5 de Firulais años ✗
```

<!--
NOTAS DEL ORADOR:
- Mostrar el ejemplo cómico del error.
- El código sigue siendo válido (no da error de sintaxis), pero la lógica está rota (error semántico). Estos son los peores bugs.
-->

---

<!-- _header: 'Argumentos con nombre' -->

# Keyword arguments

**Especificar qué va dónde:**
```python
def hacer_pizza(tamaño, ingrediente, queso):
    print(f"Pizza {tamaño}: {ingrediente}")
    print(f"Extra queso: {queso}")

# El orden no importa
hacer_pizza(tamaño="grande", 
            ingrediente="pepperoni", 
            queso=True)

hacer_pizza(queso=False, 
            ingrediente="jamón", 
            tamaño="mediana")
```

<!--
NOTAS DEL ORADOR:
- Solución: Explicitar el nombre del parámetro.
- Ventajas:
    1. No importa el orden.
    2. El código se documenta solo (se lee como una oración).
- Muy común en bibliotecas de Data Science (pandas, matplotlib) donde las funciones tienen decenas de opciones.
-->

---

<!-- _header: 'Ventajas' -->

# ¿Por qué usar keyword args?

**Más legible:**
```python
# ❌ No se entiende
conectar("localhost", 8080, True, False)

# ✅ Se entiende claramente
conectar(host="localhost", 
         puerto=8080, 
         ssl=True, 
         verbose=False)
```

**Menos errores de orden**

<!--
NOTAS DEL ORADOR:
- Comparar visualmente.
- En el primer caso, ¿qué es `True`? ¿Qué es `False`? Hay que ir a leer la definición de la función.
- En el segundo caso, se entiende al leer la llamada.
- Recomendación: Usar keywords para booleanos o números "mágicos".
-->

---

<!-- _header: 'Parámetros por defecto' -->

# Valores opcionales

```python
def saludar(nombre, formal=False):
    """Saluda, opcionalmente formal."""
    if formal:
        print(f"Buenos días, Sr./Sra. {nombre}")
    else:
        print(f"¡Hola, {nombre}!")

# Usar valor por defecto
saludar("Ana")  # ¡Hola, Ana!

# Cambiar el valor
saludar("García", formal=True)
# Buenos días, Sr./Sra. García
```

<!--
NOTAS DEL ORADOR:
- Esto permite que la función tenga un comportamiento "estándar" pero sea personalizable.
- `formal=False` en la definición significa: "Si no me dicen nada, asumo que NO es formal".
-->

---

<!-- _header: 'Reglas importantes' -->

# Orden de parámetros

**Primero sin defecto, después con defecto:**

**✅ Correcto:**
```python
def registrar(nombre, edad, activo=True):
    pass
```

**❌ Error:**
```python
def registrar(nombre, activo=True, edad):
    pass  # SyntaxError!
```

<!--
NOTAS DEL ORADOR:
- Regla de oro de sintaxis.
- ¿Por qué? Porque si llamamos `registrar("Juan", 25)`, Python no sabría si 25 es para `activo` o para `edad` si estuvieran mezclados.
- Los obligatorios van siempre a la izquierda.
-->

---

<!-- _header: 'Ejemplo práctico' -->

# Función con valores por defecto

```python
def crear_usuario(nombre, 
                  edad=18, 
                  pais="Argentina"):
    """Crea perfil de usuario."""
    print(f"Usuario: {nombre}")
    print(f"Edad: {edad}")
    print(f"País: {pais}")

# Solo el nombre (obligatorio)
crear_usuario("Ana")

# Nombre y edad
crear_usuario("Bruno", 25)

# Todo personalizado
crear_usuario("Carlos", 30, "Chile")
```

<!--
NOTAS DEL ORADOR:
- Mostrar la flexibilidad: una misma función puede llamarse de 3 formas distintas.
- Esto reduce la necesidad de tener `crear_usuario_simple`, `crear_usuario_completo`, etc. (polimorfismo ad-hoc).
-->

---

<!-- _header: 'Combinar tipos' -->

# Posicionales + Keyword

```python
def reservar(destino, dias, hotel="3 estrellas"):
    """Reserva un viaje."""
    print(f"Destino: {destino}")
    print(f"Duración: {dias} días")
    print(f"Hotel: {hotel}")

# Posicionales
reservar("París", 7)

# Posicionales + keyword
reservar("Roma", 5, hotel="5 estrellas")

# Todo keyword
reservar(destino="Madrid", dias=3, hotel="4 estrellas")
```

<!--
NOTAS DEL ORADOR:
- Se pueden mezclar, pero con cuidado.
- Regla: Una vez que empezás con keywords, tenés que seguir con keywords hasta el final de la llamada.
-->

---

<!-- _header: 'Ejercicio' -->

# Calculadora de área

**Crea una función que:**
1. Se llame `calcular_rectangulo`
2. Reciba `ancho` y `alto`
3. Calcule área (ancho × alto)
4. Imprima el resultado
5. Prueba con diferentes valores

<!--
NOTAS DEL ORADOR:
- Ejercicio rápido para fijar conceptos.
- Desafío extra: Hacer que `alto` tenga un valor por defecto (ej: cuadrado si no se especifica, aunque requeriría lógica extra, o simplemente un valor default).
-->

---

<!-- _header: 'Ejercicio - Solución' -->

# Posible solución

```python
def calcular_rectangulo(ancho, alto):
    """Calcula área de un rectángulo."""
    area = ancho * alto
    print(f"Rectángulo {ancho} × {alto}")
    print(f"Área: {area}")
    return area

# Probar
calcular_rectangulo(5, 10)  # 50
calcular_rectangulo(3, 7)   # 21

# Con keyword args (más claro)
calcular_rectangulo(ancho=4, alto=6)  # 24
```

<!--
NOTAS DEL ORADOR:
- Mencionar que agregamos `return area` aunque el enunciado solo pedía imprimir, para ir adelantando el tema de la próxima clase.
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

**Parámetros:**
* En la definición
* Separados por comas

**Argumentos:**
* Posicionales (orden importa)
* Keyword (nombre=valor)
* Por defecto (opcional)

**Orden:**
* Sin defecto primero
* Con defecto después

**Próximo:**
* Return: devolver valores

<!--
NOTAS DEL ORADOR:
- Resumen final.
- Próxima parada: `return`. Hasta ahora nuestras funciones solo imprimían (efecto secundario), ahora aprenderemos a devolver valores útiles.
-->

---

<!-- _class: centered -->

# ¿Preguntas?