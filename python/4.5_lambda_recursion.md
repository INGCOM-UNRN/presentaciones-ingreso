---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Funciones - Parte 5/6' -->

# <!-- fit --> Funciones Avanzadas
## Lambda, recursión y más
Curso de Ingreso - Ingeniería en Computación

---

<!-- _header: 'Funciones lambda' -->

# Funciones anónimas

**Función normal:**
```python
def cuadrado(x):
    return x ** 2

print(cuadrado(5))  # 25
```

**Lambda (una línea):**
```python
cuadrado = lambda x: x ** 2

print(cuadrado(5))  # 25
```

**Sintaxis:** `lambda parametros: expresion`

<!--
NOTAS DEL ORADOR:
- Lambda = función anónima de una sola expresión
- Nombre "lambda" viene del cálculo lambda (matemática)
- Sintaxis: lambda args: expresión (sin return, sin def)
- Comparación con función normal:
  * Función normal: múltiples líneas, nombre, return explícito
  * Lambda: una línea, puede ser anónima, return implícito
- Limitación: SOLO una expresión, no statements (no if/for/while multilinea)
- Usar cuando la función es simple y se usa una sola vez
- No abusar: si necesita nombre descriptivo, usar def
- Tiempo: 3-4 minutos con comparaciones lado a lado
-->

---

<!-- _header: 'Cuándo usar lambda' -->

# Casos de uso

**✅ Bueno para:**
* Funciones simples de una línea
* Usar con map, filter, sorted
* Callbacks temporales

**❌ No usar para:**
* Lógica compleja
* Múltiples líneas
* Código que se reutiliza mucho

---

<!-- _header: 'Ejemplo con sorted' -->

# Lambda en sorted()

```python
estudiantes = [
    {"nombre": "Ana", "nota": 85},
    {"nombre": "Bruno", "nota": 92},
    {"nombre": "Carlos", "nota": 78}
]

# Ordenar por nota
ordenados = sorted(estudiantes, 
                   key=lambda x: x["nota"])

for e in ordenados:
    print(f"{e['nombre']}: {e['nota']}")
```

<!--
NOTAS DEL ORADOR:
- Este es uno de los usos MÁS COMUNES de lambda
- sorted() puede tomar función key que extrae criterio de ordenamiento
- Sin lambda tendríamos que definir función separada (verboso)
- Explicar: lambda x: x["nota"] toma dict y devuelve valor de nota
- sorted() usa ese valor para comparar y ordenar
- Resultado: Carlos(78), Ana(85), Bruno(92)
- Otros ejemplos:
  * sorted(palabras, key=lambda x: len(x)) → ordena por longitud
  * sorted(nombres, key=lambda x: x.lower()) → ignora mayúsculas
- key puede ser cualquier función que tome elemento y devuelva valor comparable
- Tiempo: 4 minutos, mostrar múltiples ejemplos
-->

---

<!-- _header: 'Ejemplo con filter' -->

# Lambda en filter()

```python
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Filtrar pares
pares = list(filter(lambda x: x % 2 == 0, numeros))
print(pares)  # [2, 4, 6, 8, 10]

# Filtrar mayores a 5
mayores = list(filter(lambda x: x > 5, numeros))
print(mayores)  # [6, 7, 8, 9, 10]
```

---

<!-- _header: 'Ejemplo con map' -->

# Lambda en map()

```python
numeros = [1, 2, 3, 4, 5]

# Cuadrados
cuadrados = list(map(lambda x: x**2, numeros))
print(cuadrados)  # [1, 4, 9, 16, 25]

# Duplicar
dobles = list(map(lambda x: x*2, numeros))
print(dobles)  # [2, 4, 6, 8, 10]
```

---

<!-- _class: inverse -->

# <!-- fit --> Recursión
## Función que se llama a sí misma

---

<!-- _header: '¿Qué es recursión?' -->

# Función que se llama

**Ejemplo clásico: Factorial**
```python
def factorial(n):
    """Calcula factorial recursivamente."""
    # Caso base
    if n == 0 or n == 1:
        return 1
    # Caso recursivo
    return n * factorial(n - 1)

print(factorial(5))  # 5! = 120
```

**5! = 5 × 4 × 3 × 2 × 1**

<!--
NOTAS DEL ORADOR:
- Recursión = función que se llama a sí misma
- Concepto potente pero puede confundir al principio
- Analogía: cajas rusas (matrioshkas), espejos enfrentados
- Factorial perfecto para introducir recursión (simple, matemático)
- Componentes CRÍTICOS:
  1. Caso base: condición de parada (n == 0 o 1)
  2. Caso recursivo: llamada a sí misma con problema más pequeño
- Sin caso base → stack overflow (lazo infinito)
- Cada llamada espera a que la siguiente termine
- Stack de llamadas se construye y luego se resuelve hacia atrás
- Tiempo: 4-5 minutos, dibujar stack en pizarra si es posible
-->

---

<!-- _header: 'Cómo funciona' -->

# Ejecución paso a paso

```
factorial(5)
  = 5 * factorial(4)
  = 5 * (4 * factorial(3))
  = 5 * (4 * (3 * factorial(2)))
  = 5 * (4 * (3 * (2 * factorial(1))))
  = 5 * (4 * (3 * (2 * 1)))
  = 5 * (4 * (3 * 2))
  = 5 * (4 * 6)
  = 5 * 24
  = 120
```

<!--
NOTAS DEL ORADOR:
- CRUCIAL mostrar CÓMO se ejecuta paso a paso
- Fase 1 (EXPANSIÓN): llamadas se acumulan hasta caso base
  * factorial(5) llama factorial(4)
  * factorial(4) llama factorial(3)
  * ... hasta factorial(1) que devuelve 1
- Fase 2 (CONTRACCIÓN): resultados se calculan hacia atrás
  * factorial(1) = 1
  * factorial(2) = 2 * 1 = 2
  * factorial(3) = 3 * 2 = 6
  * ... hasta factorial(5) = 5 * 24 = 120
- Dibujar como árbol o pila (stack)
- Mencionar límite de recursión de Python (default ~1000)
- Comparar memoria: recursión usa stack, iteración no
- Tiempo: 5-6 minutos, hacer traza completa en pizarra
-->

---

<!-- _header: 'Partes de recursión' -->

# Caso base y recursivo

**Dos componentes obligatorios:**

**1. Caso base (detención):**
```python
if n == 1:
    return 1
```

**2. Caso recursivo (llamada):**
```python
return n * factorial(n - 1)
```

**Sin caso base → Lazo infinito**

---

<!-- _header: 'Ejemplo: Suma' -->

# Sumar números hasta N

```python
def suma_hasta(n):
    """Suma números de 1 a n."""
    # Caso base
    if n == 1:
        return 1
    # Caso recursivo
    return n + suma_hasta(n - 1)

print(suma_hasta(5))  # 15
# 5 + 4 + 3 + 2 + 1 = 15
```

---

<!-- _header: 'Recursión vs Iteración' -->

# Comparación

**Recursiva:**
```python
def factorial_rec(n):
    if n <= 1:
        return 1
    return n * factorial_rec(n - 1)
```

**Iterativa:**
```python
def factorial_iter(n):
    resultado = 1
    for i in range(1, n + 1):
        resultado *= i
    return resultado
```

**Ambas funcionan, elige según claridad**

<!--
NOTAS DEL ORADOR:
- TODO problema recursivo puede resolverse iterativamente
- Comparar ventajas/desventajas:
  
  RECURSIÓN:
  + Más elegante para problemas naturalmente recursivos (árboles, grafos)
  + Código más corto y legible (a veces)
  - Usa más memoria (call stack)
  - Más lenta (overhead de llamadas)
  - Riesgo de stack overflow
  
  ITERACIÓN:
  + Más eficiente en memoria
  + Más rápida
  + Sin límite de profundidad
  - Puede ser más compleja de escribir
  
- Cuándo usar recursión:
  * Problema naturalmente recursivo (Fibonacci, árboles)
  * Claridad más importante que eficiencia
  * Datos de entrada pequeños
  
- Tiempo: 4-5 minutos, discutir trade-offs
-->

---

<!-- _header: 'Funciones como objetos' -->

# Funciones de primera clase

**Asignar a variable:**
```python
def saludar():
    print("Hola")

mi_funcion = saludar
mi_funcion()  # Hola
```

**Pasar como argumento:**
```python
def ejecutar(funcion):
    funcion()

ejecutar(saludar)  # Hola
```

---

<!-- _header: 'Callback functions' -->

# Funciones como argumentos

```python
def procesar(numeros, operacion):
    """Aplica operación a cada número."""
    return [operacion(x) for x in numeros]

# Diferentes operaciones
def cuadrado(x):
    return x ** 2

def triple(x):
    return x * 3

nums = [1, 2, 3, 4]
print(procesar(nums, cuadrado))  # [1, 4, 9, 16]
print(procesar(nums, triple))    # [3, 6, 9, 12]
```

---

<!-- _header: 'Ejercicio' -->

# Fibonacci recursivo

**Crea una función que:**
1. Se llame `fibonacci`
2. Reciba un número `n`
3. Devuelva el n-ésimo número Fibonacci
4. Usa recursión
5. Fibonacci: 0, 1, 1, 2, 3, 5, 8, 13...

**Pista:** fib(n) = fib(n-1) + fib(n-2)

---

<!-- _header: 'Ejercicio - Solución' -->

# Posible solución

```python
def fibonacci(n):
    """
    Calcula el n-ésimo número Fibonacci.
    
    Args:
        n: Posición en la secuencia (0-indexed)
        
    Returns:
        int: Número Fibonacci en posición n
    """
    # Casos base
    if n == 0:
        return 0
    if n == 1:
        return 1
    # Caso recursivo
    return fibonacci(n - 1) + fibonacci(n - 2)

# Probar
for i in range(8):
    print(f"fib({i}) = {fibonacci(i)}")
```

---

<!-- _header: 'Resumen' -->

# Para recordar

**Lambda:**
* `lambda x: expresion`
* Para funciones simples
* Con map, filter, sorted

**Recursión:**
* Función se llama a sí misma
* Caso base obligatorio
* Útil para problemas dividibles

**Funciones como objetos:**
* Asignar a variables
* Pasar como argumentos
* Callbacks

**Próximo:**
* Buenas prácticas

---

<!-- _class: centered -->

# ¿Preguntas?
