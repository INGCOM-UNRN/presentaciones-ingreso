---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Funciones - Parte 6/6' -->

# <!-- fit --> Buenas Prácticas
## Escribir mejores funciones
Curso de Ingreso - Ingeniería en Computación

---

<!-- _header: 'Principio DRY' -->

# Don't Repeat Yourself

**❌ Código repetitivo:**
```python
# Calcular promedio 3 veces
suma1 = 7 + 8 + 9
prom1 = suma1 / 3

suma2 = 6 + 7 + 8
prom2 = suma2 / 3

suma3 = 9 + 9 + 10
prom3 = suma3 / 3
```

**✅ Con función:**
```python
def promedio(notas):
    return sum(notas) / len(notas)

prom1 = promedio([7, 8, 9])
prom2 = promedio([6, 7, 8])
prom3 = promedio([9, 9, 10])
```

<!--
NOTAS DEL ORADOR:
- DRY = Don't Repeat Yourself (principio fundamental)
- Problemas de código repetitivo:
  * Difícil de mantener (cambiar en múltiples lugares)
  * Propenso a errores (olvidar actualizar una copia)
  * Más código = más bugs potenciales
- Regla: si copiás y pegás código, probablemente necesitás una función
- Ventajas de función:
  * Un solo lugar para cambiar lógica
  * Más fácil de testear
  * Nombre documenta propósito
- Excepciones: duplicación accidental vs esencial
- Relacionado con: abstracción, modularidad
- Tiempo: 3-4 minutos con ejemplos del mundo real
-->

---

<!-- _header: 'Principio SRP' -->

# Single Responsibility

**❌ Hace demasiado:**
```python
def procesar_usuario(nombre, edad):
    # Validar
    if len(nombre) < 2:
        return False
    # Guardar en BD
    db.save(nombre, edad)
    # Enviar email
    send_email(nombre)
    # Generar reporte
    create_report(nombre)
```

**✅ Una responsabilidad:**
```python
def validar_nombre(nombre):
    return len(nombre) >= 2

def guardar_usuario(nombre, edad):
    db.save(nombre, edad)

def enviar_bienvenida(nombre):
    send_email(nombre)
```

<!--
NOTAS DEL ORADOR:
- SRP = Single Responsibility Principle (de SOLID)
- Cada función debe tener UNA y solo UNA razón para cambiar
- Función en ejemplo malo hace 4 cosas:
  1. Validar
  2. Guardar en BD
  3. Enviar email
  4. Generar reporte
- Problemas:
  * Difícil de testear (muchas dependencias)
  * Difícil de reutilizar (¿y si solo quiero validar?)
  * Frágil (cambio en email afecta toda función)
- Solución: separar en funciones pequeñas y cohesivas
- Cada función hace UNA cosa y la hace bien
- Más fácil de: testear, mantener, reutilizar, entender
- Relacionado con: cohesión, acoplamiento bajo
- Tiempo: 4-5 minutos, discutir granularidad apropiada
-->

---

<!-- _header: 'Tamaño de funciones' -->

# Funciones pequeñas

**Regla general:**
* Máximo 20-30 líneas
* Una pantalla visible
* Un nivel de abstracción

**Si es muy larga:**
* Dividir en sub-funciones
* Extraer lógica compleja

---

<!-- _header: 'Nombres descriptivos' -->

# Nombres claros

**✅ Buenos nombres:**
```python
def calcular_precio_con_descuento(precio, descuento)
def validar_email(email)
def obtener_usuarios_activos()
def es_numero_par(numero)
```

**❌ Malos nombres:**
```python
def proc(p, d)  # Muy corto
def x(email)    # Sin sentido
def get()       # ¿Qué obtiene?
def check(n)    # ¿Qué verifica?
```

---

<!-- _header: 'Parámetros' -->

# Cantidad de parámetros

**Recomendación:**
* 0-2 parámetros: Ideal
* 3 parámetros: Aceptable
* 4+ parámetros: Considerar refactorizar

**Más de 3 → Usar objeto/diccionario:**
```python
# ❌ Muchos parámetros
def crear_usuario(nombre, edad, email, ciudad, pais)

# ✅ Usar diccionario
def crear_usuario(datos_usuario):
    # datos_usuario = {nombre, edad, email...}
```

---

<!-- _header: 'Valores por defecto' -->

# Parámetros opcionales

```python
def conectar_db(host="localhost", 
                puerto=5432, 
                timeout=30):
    """Conecta a base de datos."""
    # Usar valores por defecto o personalizados
    pass

# Usar defaults
conectar_db()

# Personalizar
conectar_db(host="servidor.com", timeout=60)
```

**Defaults para casos comunes**

---

<!-- _header: 'Documentación' -->

# Docstrings completos

```python
def calcular_descuento(precio, porcentaje):
    """
    Calcula precio con descuento aplicado.
    
    Args:
        precio (float): Precio original
        porcentaje (float): Descuento (0-100)
        
    Returns:
        float: Precio final con descuento
        
    Raises:
        ValueError: Si porcentaje no está en 0-100
        
    Example:
        >>> calcular_descuento(100, 20)
        80.0
    """
    if not 0 <= porcentaje <= 100:
        raise ValueError("Porcentaje inválido")
    return precio * (1 - porcentaje/100)
```

---

<!-- _header: 'Validación de entrada' -->

# Verificar parámetros

```python
def dividir(a, b):
    """Divide dos números."""
    # Validar entrada
    if b == 0:
        raise ValueError("No se puede dividir por 0")
    if not isinstance(a, (int, float)):
        raise TypeError("a debe ser número")
    if not isinstance(b, (int, float)):
        raise TypeError("b debe ser número")
    
    return a / b
```

**Fallar rápido y claro**

<!--
NOTAS DEL ORADOR:
- Validación de entrada es CRÍTICA para funciones robustas
- Principio "Fail Fast": detectar errores lo antes posible
- Validaciones comunes:
  * Tipos correctos (isinstance)
  * Rangos válidos (edad > 0)
  * Valores no nulos
  * Condiciones de negocio (división por 0)
- Dónde validar:
  * Al inicio de función (guard clauses)
  * Antes de operaciones críticas
- Tipos de errores:
  * ValueError: valor incorrecto pero tipo correcto
  * TypeError: tipo incorrecto
  * AssertionError: condición de integridad violada
- Mensajes claros: "No se puede dividir por 0" vs "Error"
- Trade-off: validación vs performance
- Tiempo: 4 minutos, mostrar debugging mejorado
-->

---

<!-- _header: 'Efectos secundarios' -->

# Funciones puras

**❌ Con efectos secundarios:**
```python
total = 0

def sumar(x):
    global total
    total += x  # Modifica estado global
    return total
```

**✅ Sin efectos secundarios:**
```python
def sumar(total, x):
    return total + x  # Solo calcula

total = 0
total = sumar(total, 5)
```

<!--
NOTAS DEL ORADOR:
- Función pura = sin efectos secundarios (side effects)
- Efectos secundarios = modificar algo fuera de la función:
  * Variables globales
  * Parámetros mutables (listas, dicts)
  * Archivos, BD, red
  * Imprimir en pantalla
- Ventajas de funciones puras:
  * Predecibles: misma entrada → misma salida
  * Testables: no dependen de estado externo
  * Reutilizables: funcionan en cualquier contexto
  * Paralelizables: sin race conditions
- Cuándo son necesarios efectos secundarios:
  * I/O (leer archivo, DB, usuario)
  * Logging
  * Actualizar UI
- Práctica: minimizar efectos secundarios, aislarlos
- Relacionado con: programación funcional, inmutabilidad
- Tiempo: 4-5 minutos, comparar debugging
-->

---

<!-- _header: 'Return temprano' -->

# Guard clauses

**❌ Anidación profunda:**
```python
def procesar(dato):
    if dato is not None:
        if len(dato) > 0:
            if dato.isdigit():
                return int(dato)
    return None
```

**✅ Return temprano:**
```python
def procesar(dato):
    if dato is None:
        return None
    if len(dato) == 0:
        return None
    if not dato.isdigit():
        return None
    return int(dato)
```

<!--
NOTAS DEL ORADOR:
- Guard clauses = validaciones tempranas con return inmediato
- Problema de anidación profunda:
  * Difícil de leer (indent hell)
  * Lógica principal enterrada al final
  * Difícil seguir camino de ejecución
- Patrón guard clause:
  1. Verificar condiciones de error primero
  2. Return/raise inmediatamente si no cumple
  3. Código principal al final sin indent
- Ventajas:
  * Más lineal y fácil de seguir
  * Condiciones de error claras al inicio
  * Reduce complejidad cognitiva
  * Camino feliz (happy path) al final
- Similar a: early return, fail fast
- Python permite múltiples returns (otros lenguajes no)
- Tiempo: 3-4 minutos, mostrar flujo de ejecución
-->

---

<!-- _header: 'Composición' -->

# Funciones llamando funciones

```python
def validar_email(email):
    """Valida formato de email."""
    return "@" in email and "." in email

def validar_edad(edad):
    """Valida rango de edad."""
    return 0 < edad < 120

def validar_usuario(email, edad):
    """Valida datos completos de usuario."""
    if not validar_email(email):
        return False
    if not validar_edad(edad):
        return False
    return True
```

---

<!-- _header: 'Testing' -->

# Funciones fáciles de probar

**Características:**
* Sin efectos secundarios
* Entrada → Salida predecible
* Sin dependencias externas

```python
def es_palindromo(texto):
    """Verifica si texto es palíndromo."""
    texto = texto.lower().replace(" ", "")
    return texto == texto[::-1]

# Fácil de probar
assert es_palindromo("ana") == True
assert es_palindromo("hola") == False
assert es_palindromo("anita lava la tina") == True
```

---

<!-- _header: 'Checklist' -->

# Antes de finalizar función

**Verifica:**
- [ ] Nombre descriptivo (verbo)
- [ ] Una responsabilidad clara
- [ ] Docstring completo
- [ ] Máximo 2-3 parámetros
- [ ] Validación de entrada
- [ ] Maneja errores
- [ ] Sin efectos secundarios
- [ ] Fácil de probar
- [ ] < 30 líneas

---

<!-- _header: 'Ejemplo completo' -->

# Función bien diseñada

```python
def calcular_precio_final(precio_base, 
                          descuento=0, 
                          iva=21):
    """
    Calcula precio final con descuento e IVA.
    
    Args:
        precio_base: Precio sin modificar
        descuento: Porcentaje descuento (0-100)
        iva: Porcentaje IVA (default 21)
        
    Returns:
        float: Precio final
        
    Raises:
        ValueError: Si valores fuera de rango
    """
    # Validar
    if precio_base < 0:
        raise ValueError("Precio no puede ser negativo")
    if not 0 <= descuento <= 100:
        raise ValueError("Descuento debe estar entre 0-100")
    
    # Calcular
    precio_con_descuento = precio_base * (1 - descuento/100)
    precio_final = precio_con_descuento * (1 + iva/100)
    
    return round(precio_final, 2)
```

---

<!-- _class: inverse -->

# <!-- fit --> ¡Funciones completas!
## Ahora escribís mejor código

---

<!-- _header: 'Resumen completo' -->

# Lo que aprendiste

**Básico:**
* Definir y llamar funciones
* Parámetros y argumentos
* Return

**Intermedio:**
* Scope de variables
* Parámetros por defecto
* Documentación

**Avanzado:**
* Lambda y recursión
* Funciones como objetos
* Buenas prácticas

---

<!-- _header: 'Habilidades' -->

# Ahora podés

**Crear:**
* Código modular y reutilizable
* Funciones bien documentadas
* Programas organizados

**Aplicar:**
* DRY y SRP
* Validaciones
* Composición de funciones

**Próximo capítulo:**
* Cómo pensar problemas complejos

---

<!-- _class: centered -->

# ¡Felicitaciones!
## Funciones completadas

---

<!-- _class: centered -->

# ¿Preguntas?
