---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingenier√≠a en Computaci√≥n - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Estructuras de Datos - Parte 2/5' -->

# <!-- fit --> Listas: B√°sico
## Creaci√≥n, acceso y modificaci√≥n
Curso de Ingreso - Ingenier√≠a en Computaci√≥n

<!--
NOTAS DEL ORADOR:
- Duraci√≥n estimada: 3 minutos
- Objetivo: Dominar la estructura de datos m√°s importante de Python.
- Gancho: "¬øRecuerdan la mochila del cap√≠tulo anterior? Ahora vamos a aprender a guardar cosas, sacarlas y encontrarlas por su n√∫mero de bolsillo."
-->

---

<!-- _header: '¬øQu√© es una lista?' -->

# Colecci√≥n ordenada

**Lista:**
* Secuencia de elementos
* Cada uno en una posici√≥n
* Mantiene el orden
* Puede tener duplicados

**Como una fila de cajitas numeradas**

<!--
NOTAS DEL ORADOR:
- Analog√≠a visual: Fila de casilleros de correo, o asientos numerados en el cine.
- "Ordenada" no significa "de menor a mayor", significa que si pongo "A" y luego "B", se quedan as√≠.
- La diferencia con el Set es crucial: aqu√≠ importa EL LUGAR.
-->

---

<!-- _header: 'Caracter√≠sticas' -->

# Propiedades de las listas

**Ordenada:**
* Cada elemento tiene posici√≥n fija
* Posici√≥n = √≠ndice

**Mutable:**
* Pod√©s cambiar elementos
* Agregar o quitar
* Modificar despu√©s de crear

**Vers√°til:**
* Cualquier tipo de dato
* Mezclados si quer√©s

<!--
NOTAS DEL ORADOR:
- Mutabilidad: Puedo cambiar el contenido de la cajita 3 sin romper la caja.
- Heterog√©nea: `[1, "hola", True]` es v√°lido en Python (aunque no siempre recomendable mezclar mucho).
-->

---

<!-- _header: 'Crear listas' -->

# Tres formas

**1. Lista vac√≠a:**
```python
mi_lista = []
otra = list()
```

**2. Con elementos:**
```python
numeros = [1, 2, 3, 4, 5]
frutas = ["manzana", "banana", "naranja"]
```

**3. Mixta:**
```python
mixta = [1, "texto", 3.14, True]
```

<!--
NOTAS DEL ORADOR:
- `[]` es az√∫car sint√°ctica para `list()`. Es lo m√°s usado.
- Crear listas vac√≠as es √∫til para luego llenarlas con un bucle (patr√≥n acumulador).
-->

---

<!-- _header: 'Lista legible' -->

# M√∫ltiples l√≠neas

**Para listas largas:**
```python
colores = [
    "rojo",
    "naranja",
    "amarillo",
    "verde",
    "azul",
]  # Coma final permitida
```

**M√°s f√°cil de leer y modificar**

<!--
NOTAS DEL ORADOR:
- "Trailing comma" (coma final): Python la permite y es genial para diffs de Git.
- Mejora la legibilidad vertical.
-->

---

<!-- _class: inverse -->

# <!-- fit --> √çndices
## Acceder a elementos

<!--
NOTAS DEL ORADOR:
- Aqu√≠ viene el concepto m√°s contraintuitivo para los humanos: contar desde cero.
-->

---

<!-- _header: 'La regla del 0' -->

# Contamos desde 0

**¬°IMPORTANTE!**
* Primer elemento ‚Üí √≠ndice 0
* Segundo elemento ‚Üí √≠ndice 1
* Tercer elemento ‚Üí √≠ndice 2

```python
frutas = ["üçé", "üçå", "üçä"]
#        [0]   [1]   [2]

print(frutas[0])  # üçé Primera
print(frutas[1])  # üçå Segunda
print(frutas[2])  # üçä Tercera
```

<!--
NOTAS DEL ORADOR:
- ESTO ES CR√çTICO y suele confundir a principiantes
- Explicar por qu√© se cuenta desde 0 (herencia de C, eficiencia de memoria)
- Usar ejemplo f√≠sico: si hay 3 cajitas, se numeran 0, 1, 2
- Remarcar: posici√≥n 0 = primer elemento, NO el "cero-√©simo"
- Error com√∫n: intentar frutas[3] cuando solo hay 3 elementos (0,1,2)
- Hacer ejercicio mental: "Si tengo 5 elementos, ¬øcu√°l es el √∫ltimo √≠ndice?" (4)

- "Off-by-one error" (Error por uno): Es el bug m√°s com√∫n.
- Memorizar: El √≠ndice es la DISTANCIA desde el inicio. El primero est√° a distancia 0.
-->

---

<!-- _header: '√çndices negativos' -->

# Contar desde el final

**Con n√∫meros negativos:**
* √öltimo elemento ‚Üí √≠ndice -1
* Pen√∫ltimo ‚Üí √≠ndice -2

```python
frutas = ["üçé", "üçå", "üçä", "üçê"]

print(frutas[-1])  # üçê √öltima
print(frutas[-2])  # üçä Pen√∫ltima
print(frutas[-3])  # üçå Antepen√∫ltima
```

**√ötil cuando no sab√©s el tama√±o**

<!--
NOTAS DEL ORADOR:
- Magia de Python. En otros lenguajes tendr√≠as que hacer `lista[len(lista)-1]`.
- `-1` siempre es el √∫ltimo. S√∫per pr√°ctico.
-->

---

<!-- _header: '√çndices visuales' -->

# Positivos y negativos

```python
lista = ["A", "B", "C", "D"]
```

**√çndices positivos:**
```
 ["A", "B", "C", "D"]
   0    1    2    3
```

**√çndices negativos:**
```
 ["A", "B", "C", "D"]
  -4   -3   -2   -1
```

<!--
NOTAS DEL ORADOR:
- Gr√°fico mental.
- Notar la simetr√≠a.
-->

---

<!-- _header: 'Error com√∫n' -->

# √çndice fuera de rango

**‚ùå Error:**
```python
frutas = ["üçé", "üçå"]

print(frutas[5])  # IndexError!
# Solo hay 2 elementos (√≠ndices 0 y 1)
```

**‚úÖ Verificar tama√±o:**
```python
print(len(frutas))  # 2
# √çndices v√°lidos: 0 a 1
```

<!--
NOTAS DEL ORADOR:
- `IndexError: list index out of range`.
- Si la longitud es N, el √∫ltimo √≠ndice v√°lido es N-1.
-->

---

<!-- _header: 'Modificar elementos' -->

# Cambiar valores

**Asignar nuevo valor:**
```python
frutas = ["manzana", "banana", "naranja"]

frutas[1] = "pera"  # Cambiar segunda

print(frutas)
# ["manzana", "pera", "naranja"]
```

**Las listas son mutables**

<!--
NOTAS DEL ORADOR:
- Asignaci√≥n por √≠ndice.
- Destruye el valor anterior en esa posici√≥n.
-->

---

<!-- _header: 'Agregar elementos' -->

# append() - Al final

```python
frutas = ["manzana", "banana"]

frutas.append("naranja")

print(frutas)
# ["manzana", "banana", "naranja"]
```

**append() agrega al final siempre**

<!--
NOTAS DEL ORADOR:
- El m√©todo m√°s usado.
- Hace crecer la lista din√°micamente. No hace falta decir el tama√±o antes.
-->

---

<!-- _header: 'Agregar elementos' -->

# insert() - En posici√≥n

```python
frutas = ["manzana", "banana"]

frutas.insert(1, "pera")  # posici√≥n, valor

print(frutas)
# ["manzana", "pera", "banana"]
```

**insert(√≠ndice, elemento)**

<!--
NOTAS DEL ORADOR:
- Desplaza todo lo dem√°s a la derecha.
- Menos eficiente que `append` para listas muy grandes, pero √∫til.
-->

---

<!-- _header: 'Visualizando insert' -->

# ¬øQu√© pasa con insert?

**Lista original:** `["A", "B", "C"]`
**Operaci√≥n:** `lista.insert(1, "X")`

| √çndice | 0 | 1 | 2 | 3 |
|:-------|:--|:--|:--|:--|
| Antes | "A" | "B" | "C" | - |
| Acci√≥n | "A" | **"X"** | "B" ‚Üí | "C" ‚Üí |
| Despu√©s| "A" | "X" | "B" | "C" |

**Todo se desplaza a la derecha**

<!--
NOTAS DEL ORADOR:
- Esta tabla muestra el costo oculto de `insert`.
- Para meter algo en el medio, tengo que empujar todo lo dem√°s.
- "B" pasa del √≠ndice 1 al 2. "C" pasa del 2 al 3.
-->

---

<!-- _header: 'Eliminar elementos' -->

# Tres formas

**remove() - Por valor:**
```python
frutas.remove("banana")  # Elimina "banana"
```

**pop() - Por √≠ndice:**
```python
fruta = frutas.pop(1)  # Elimina y retorna
```

**del - Por √≠ndice:**
```python
del frutas[0]  # Elimina primera
```

<!--
NOTAS DEL ORADOR:
- `remove` busca el primero que coincida y lo borra. Error si no est√°.
- `pop` saca el √∫ltimo por defecto (como una pila de platos).
- `del` es una instrucci√≥n de Python, no un m√©todo.
-->

---

<!-- _header: 'Visualizando pop' -->

# ¬øQu√© pasa con pop?

**Lista:** `["A", "X", "B", "C"]`
**Operaci√≥n:** `lista.pop(1)`

| √çndice | 0 | 1 | 2 | 3 |
|:-------|:--|:--|:--|:--|
| Antes | "A" | **"X"** | "B" | "C" |
| Acci√≥n | "A" | ‚Üê "B" | ‚Üê "C" | (vac√≠o) |
| Despu√©s| "A" | "B" | "C" | - |

**Todo se desplaza a la izquierda**

<!--
NOTAS DEL ORADOR:
- Al sacar algo del medio, el agujero se cierra.
- "B" pasa del √≠ndice 2 al 1.
-->

---

<!-- _header: 'Operaciones b√°sicas' -->

# len(), in, +

**Longitud:**
```python
print(len(frutas))  # Cantidad
```

**Pertenencia:**
```python
print("manzana" in frutas)  # True/False
```

**Concatenar:**
```python
lista1 = [1, 2]
lista2 = [3, 4]
total = lista1 + lista2  # [1, 2, 3, 4]
```

<!--
NOTAS DEL ORADOR:
- Repaso de operadores polim√≥rficos.
-->

---

<!-- _header: 'Recorrer listas' -->

# Lazo for

**Iterar elementos:**
```python
frutas = ["manzana", "banana", "naranja"]

for fruta in frutas:
    print(fruta)
```

**Salida:**
```
manzana
banana
naranja
```

<!--
NOTAS DEL ORADOR:
- La forma est√°ndar de procesar listas.
- "Para cada fruta en frutas..."
-->

---

<!-- _header: 'Recorrer con √≠ndice' -->

# enumerate()

**Obtener √≠ndice y valor:**
```python
frutas = ["manzana", "banana", "naranja"]

for i, fruta in enumerate(frutas):
    print(f"{i}: {fruta}")
```

**Salida:**
```
0: manzana
1: banana
2: naranja
```

<!--
NOTAS DEL ORADOR:
- enumerate() es m√°s elegante que usar range(len(lista))
- Explicar el unpacking: i, fruta = (√≠ndice, valor)
- Mostrar alternativa menos pyth√≥nica:
  for i in range(len(frutas)):
      print(f"{i}: {frutas[i]}")
- Mencionar par√°metro start: enumerate(frutas, start=1) para √≠ndices desde 1
- Casos de uso: numerar elementos, necesitar posici√≥n y valor simult√°neamente
- Ejercicio: crear lista numerada con prefijo de posici√≥n

- `enumerate` es pyth√≥nico. Evita hacer `range(len(lista))`.
- Desempaquetado de tupla `i, fruta`.
-->

---

<!-- _header: 'Ejercicio' -->

# Lista de compras

**Crea un programa que:**
1. Cree lista vac√≠a de compras
2. Agregue 3 productos
3. Muestre la lista
4. Elimine un producto
5. Muestre lista final

<!--
NOTAS DEL ORADOR:
- Ejercicio integrador.
-->

---

<!-- _header: 'Ejercicio - Soluci√≥n' -->

# Posible soluci√≥n

```python
# 1. Crear lista vac√≠a
compras = []

# 2. Agregar productos
compras.append("pan")
compras.append("leche")
compras.append("huevos")

# 3. Mostrar
print("Lista inicial:", compras)

# 4. Eliminar
compras.remove("leche")

# 5. Mostrar final
print("Lista final:", compras)
```

---

<!-- _header: 'Resumen' -->

# Para recordar

**Crear:**
* `[]` o `list()`

**Acceder:**
* √çndice positivo: `lista[0]`
* √çndice negativo: `lista[-1]`

**Modificar:**
* `lista[i] = valor`
* `append()`, `insert()`
* `remove()`, `pop()`, `del`

**Recorrer:**
* `for item in lista`
* `enumerate(lista)`

**Pr√≥ximo:**
* Slicing y m√©todos avanzados

<!--
NOTAS DEL ORADOR:
- Cierre.
-->

---

<!-- _class: centered -->

# ¬øPreguntas?
