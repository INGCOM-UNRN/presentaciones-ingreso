---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Estructuras de Datos - Parte 3/5' -->

# <!-- fit --> Listas: Slicing y Métodos
## Técnicas avanzadas
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Duración estimada: 3 minutos
- Objetivo: Manejar subconjuntos de datos y entender la mutabilidad.
- Gancho: "¿Cómo cortan una torta? En porciones. El slicing es cortar porciones de datos."
-->

---

<!-- _header: 'Slicing' -->

# Rebanadas de lista

**Sintaxis:**
```python
lista[inicio:fin:paso]
```

**No incluye el índice fin**

```python
numeros = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numeros[2:5])   # [2, 3, 4]
print(numeros[:3])    # [0, 1, 2]
print(numeros[7:])    # [7, 8, 9]
print(numeros[::2])   # [0, 2, 4, 6, 8]
```

<!--
NOTAS DEL ORADOR:
- Intervalo semi-abierto: [inicio, fin).
- Si omito inicio, es 0. Si omito fin, es len().
- El paso (step) permite saltar elementos.

- Slicing es una de las características más potentes de Python
- Sintaxis: [inicio:fin:paso] - todos opcionales
- CRÍTICO: el índice fin NO se incluye (matemáticamente [inicio, fin))
- Ejemplos paso a paso:
  * [2:5] toma índices 2, 3, 4 (NO el 5)
  * [:3] desde inicio hasta 3 (no incluido)
  * [7:] desde 7 hasta el final
  * [::2] todos con paso 2 (salteando uno)
- Memoria: crea NUEVA lista, no modifica original
- Comparar con otros lenguajes (substring, substr)
- Tiempo: 4-5 minutos con ejemplos prácticos
-->

---

<!-- _header: 'Slicing común' -->

# Patrones útiles

**Primeros N:**
```python
lista[:3]  # Primeros 3
```

**Últimos N:**
```python
lista[-3:]  # Últimos 3
```

**Invertir:**
```python
lista[::-1]  # Lista al revés
```

**Saltar elementos:**
```python
lista[::2]  # Cada 2
```

<!--
NOTAS DEL ORADOR:
- `lista[::-1]` es el "idiom" estándar de Python para invertir.
-->

---

<!-- _header: 'Métodos útiles' -->

# Ordenar: sort()

**sort() - modifica la lista:**
```python
numeros = [3, 1, 4, 1, 5]
numeros.sort()
print(numeros)  # [1, 1, 3, 4, 5]
```

**sorted() - crea nueva lista:**
```python
numeros = [3, 1, 4, 1, 5]
ordenados = sorted(numeros)
print(numeros)     # [3, 1, 4, 1, 5]
print(ordenados)   # [1, 1, 3, 4, 5]
```

<!--
NOTAS DEL ORADOR:
- Distinción crítica: "In-place" (sort) vs "Return new" (sorted).
- `sort` devuelve `None`. Error común: `x = lista.sort()`.
-->

---

<!-- _header: 'Visualizando Sort' -->

# ¿Cómo se ordena?

**Lista:** `[3, 1, 4, 2]`

1. **Estado inicial:** `[3, 1, 4, 2]`
2. **Comparar 3 y 1:** Intercambiar → `[1, 3, 4, 2]`
3. **Comparar 3 y 4:** Ordenados → `[1, 3, 4, 2]`
4. **Comparar 4 y 2:** Intercambiar → `[1, 3, 2, 4]`
5. **Repetir...** hasta que todo esté ordenado

**Resultado final:** `[1, 2, 3, 4]`

<!--
NOTAS DEL ORADOR:
- Una simplificación del Bubble Sort para visualizar el concepto de "ordenamiento in-place".
- `sort()` de Python usa Timsort, que es mucho más eficiente, pero la idea es entender que los elementos se mueven.
-->

---

<!-- _header: 'Métodos útiles' -->

# Invertir: reverse()

```python
frutas = ["manzana", "banana", "naranja"]

frutas.reverse()

print(frutas)
# ["naranja", "banana", "manzana"]
```

**Modifica la lista original**

<!--
NOTAS DEL ORADOR:
- También es "in-place".
-->

---

<!-- _header: 'Métodos útiles' -->

# Contar y buscar

**count() - cuántas veces aparece:**
```python
numeros = [1, 2, 3, 2, 1, 2]
print(numeros.count(2))  # 3
```

**index() - posición de elemento:**
```python
frutas = ["manzana", "banana", "naranja"]
print(frutas.index("banana"))  # 1
```

<!--
NOTAS DEL ORADOR:
- `index` lanza error si no encuentra el elemento. Usar `in` antes para verificar si querés evitar el error.
-->

---

<!-- _header: 'Copiar listas' -->

# Copia superficial vs profunda

**❌ Asignación (no copia):**
```python
lista1 = [1, 2, 3]
lista2 = lista1  # Misma lista!
lista2[0] = 99
print(lista1)  # [99, 2, 3]
```

**✅ Copiar:**
```python
lista1 = [1, 2, 3]
lista2 = lista1.copy()
lista2[0] = 99
print(lista1)  # [1, 2, 3]
```

<!--
NOTAS DEL ORADOR:
- Explicación de referencias. `lista2 = lista1` solo copia la etiqueta, no la caja.
- `.copy()` crea una nueva caja con los mismos contenidos (en el primer nivel).
-->

---

<!-- _header: 'List comprehension' -->

# Crear listas compactas

**Sintaxis:**
```python
[expresion for item in iterable if condicion]
```

**Ejemplo - Cuadrados:**
```python
cuadrados = [x**2 for x in range(5)]
print(cuadrados)  # [0, 1, 4, 9, 16]
```

**Con filtro:**
```python
pares = [x for x in range(10) if x % 2 == 0]
print(pares)  # [0, 2, 4, 6, 8]
```

<!--
NOTAS DEL ORADOR:
- La joya de Python. Potente y expresivo.
- Se lee casi como notación matemática de conjuntos: { x² | x ∈ N, x < 5 }.

- List comprehension es MUY pythónico y elegante
- Comparar con forma tradicional:
  cuadrados = []
  for x in range(5):
      cuadrados.append(x**2)
- Estructura: [QUÉ_HACER for ITEM in COLECCIÓN if CONDICIÓN]
- Leer de izquierda a derecha: "crea lista con x² para cada x en rango"
- El if es opcional (filtro)
- Ventajas: más corto, más rápido, más legible (una vez que se aprende)
- No abusar: si es muy complejo, mejor usar lazo tradicional
- Ejemplo interactivo: [palabra.upper() for palabra in ["hola", "mundo"]]


-->

---

<!-- _header: 'Visualizando Comprehension' -->

# Paso a paso

**Código:** `[x*2 for x in [1, 2, 3]]`

1. **Crear lista vacía:** `[]`
2. **Iterar x=1:** Calcular `1*2=2`. Agregar → `[2]`
3. **Iterar x=2:** Calcular `2*2=4`. Agregar → `[2, 4]`
4. **Iterar x=3:** Calcular `3*2=6`. Agregar → `[2, 4, 6]`

**Resultado:** `[2, 4, 6]`

<!--
NOTAS DEL ORADOR:
- Desmitificar la comprehension.
- Es solo un bucle for condensado.
-->

---

<!-- _header: 'Listas anidadas' -->

# Listas dentro de listas

```python
matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print(matriz[0])     # [1, 2, 3]
print(matriz[0][0])  # 1
print(matriz[1][2])  # 6
```

**Útil para tablas, grillas, matrices**

<!--
NOTAS DEL ORADOR:
- Matrices, tableros de juego, imágenes (píxeles).
-->

---

<!-- _class: inverse -->

# <!-- fit --> Sets (Conjuntos)
## Elementos únicos

<!--
NOTAS DEL ORADOR:
- Cambio de estructura. Dejamos el orden, ganamos unicidad y velocidad.
-->

---

<!-- _header: '¿Qué es un set?' -->

# Colección única

**Set:**
* Sin duplicados
* Sin orden
* No indexable
* Búsqueda rápida

```python
tags = {"python", "code", "python"}
print(tags)  # {"python", "code"}
# Elimina duplicados automáticamente
```

<!--
NOTAS DEL ORADOR:
- Teoría de conjuntos matemática.
- Ideal para "bolsa de etiquetas" o "usuarios que visitaron".

- Sets son colecciones NO ordenadas de elementos ÚNICOS
- Diferencia clave con listas: no hay duplicados, no hay índices
- Basado en tablas hash → búsqueda O(1) muy eficiente
- Casos de uso:
  * Eliminar duplicados de lista
  * Verificar pertenencia rápidamente (x in set es rápido)
  * Operaciones matemáticas de conjuntos (unión, intersección)
- No se puede acceder por índice: set[0] da error
- Orden puede cambiar entre ejecuciones (no garantizado)
- Elementos deben ser inmutables (no puede contener listas)
-->

---

<!-- _header: 'Crear sets' -->

# Sintaxis

**Con llaves {}:**
```python
frutas = {"manzana", "banana", "naranja"}
```

**Con set():**
```python
vacio = set()  # Set vacío
desde_lista = set([1, 2, 2, 3])  # {1, 2, 3}
```

**⚠️ {} es dict, no set vacío**

<!--
NOTAS DEL ORADOR:
- Trampa: `{}` crea un diccionario vacío, no un set.
-->

---

<!-- _header: 'Operaciones básicas' -->

# add, remove, discard

**Agregar:**
```python
tags = {"python"}
tags.add("java")
print(tags)  # {"python", "java"}
```

**Eliminar:**
```python
tags.remove("java")  # Error si no existe
tags.discard("ruby")  # No error
```

<!--
NOTAS DEL ORADOR:
- `add` en vez de `append` (porque no hay final).
- `discard` es más seguro que `remove`.
-->

---

<!-- _header: 'Operaciones de conjuntos' -->

# Unión e intersección

**Unión (|):**
```python
a = {1, 2, 3}
b = {3, 4, 5}
print(a | b)  # {1, 2, 3, 4, 5}
```

**Intersección (&):**
```python
print(a & b)  # {3}
```

**Diferencia (-):**
```python
print(a - b)  # {1, 2}
```

<!--
NOTAS DEL ORADOR:
- Diagramas de Venn mentales.
- Muy útil para filtrar datos.
-->

---

<!-- _header: 'Métodos de conjuntos' -->

# union(), intersection()

**Métodos equivalentes:**
```python
a = {1, 2, 3}
b = {3, 4, 5}

print(a.union(b))          # {1, 2, 3, 4, 5}
print(a.intersection(b))   # {3}
print(a.difference(b))     # {1, 2}
```

**Mismo resultado, sintaxis diferente**

---

<!-- _header: 'Ejercicio' -->

# Eliminar duplicados

**Crea un programa que:**
1. Tenga lista con duplicados
2. Convierta a set
3. Vuelva a lista
4. Muestre resultado

```python
numeros = [1, 2, 2, 3, 4, 4, 5]
# Resultado esperado: [1, 2, 3, 4, 5]
```

<!--
NOTAS DEL ORADOR:
- Patrón clásico para limpiar datos.
-->

---

<!-- _header: 'Ejercicio - Solución' -->

# Posible solución

```python
# Lista con duplicados
numeros = [1, 2, 2, 3, 4, 4, 5]
print("Original:", numeros)

# Convertir a set (elimina duplicados)
unicos = set(numeros)
print("Set:", unicos)

# Volver a lista
sin_duplicados = list(unicos)
print("Sin duplicados:", sin_duplicados)
```

---

<!-- _header: 'Resumen' -->

# Para recordar

**Listas - Slicing:**
* `lista[inicio:fin:paso]`
* Patrones: `[:N]`, `[-N:]`, `[::-1]`

**Listas - Métodos:**
* `sort()`, `reverse()`
* `count()`, `index()`
* List comprehension

**Sets:**
* Sin duplicados, sin orden
* `add()`, `remove()`, `discard()`
* Operaciones: `|`, `&`, `-`

<!--
NOTAS DEL ORADOR:
- Cierre.
-->

---

<!-- _class: centered -->

# ¡Estructuras completadas!
## Listas y Sets dominados

---

<!-- _class: centered -->

# ¿Preguntas?