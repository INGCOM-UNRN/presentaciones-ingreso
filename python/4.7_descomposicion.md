---
marp: true
theme: UNRN
paginate: false
header: 'UNRN Andina'
footer: 'Curso de Ingreso - Ingeniería en Computación - UNRN Andina'
size: 4:3
---

<!-- _class: lead -->
<!-- _footer: 'Funciones - Parte 7' -->

# <!-- fit --> Descomposición Funcional
## Dividir para conquistar
Curso de Ingreso - Ingeniería en Computación

<!--
NOTAS DEL ORADOR:
- Esta es una de las habilidades más importantes en programación
- "Dividir para conquistar" es una estrategia milenaria que aplica perfectamente al código
- Gancho: "¿Alguna vez trataron de armar un mueble de IKEA sin las instrucciones paso a paso? La descomposición funcional es crear esas instrucciones para tu código"
- Duración estimada: 40-50 minutos
- Objetivo: Que los estudiantes puedan tomar un problema y dividirlo en funciones manejables
-->

---

<!-- _header: '¿Qué es?' -->

# Descomposición Funcional

**Definición:**
Dividir un problema complejo en subproblemas más pequeños

Cada subproblema se resuelve con una función específica

**Analogía:**
Es como desarmar un motor en piezas individuales

Pistones, bielas, válvulas... cada una con función clara

<!--
NOTAS DEL ORADOR:
- Definición formal: técnica de diseño que divide un sistema en partes más pequeñas
- Otras analogías útiles:
  * Receta de cocina: pasos individuales para un plato complejo
  * Construcción de casa: cimientos, paredes, techo, instalaciones
  * Orquesta: cada músico toca su parte, juntos hacen la sinfonía
- Pregunta al grupo: "¿Cómo harían para explicarle a alguien cómo hacer un café?"
- Respuesta esperada: moler, calentar agua, filtrar... ¡eso es descomponer!
-->

---

<!-- _class: inverse -->

# <!-- fit --> ¿Por qué descomponer?
## El problema del código monolítico

<!--
NOTAS DEL ORADOR:
- Slide de transición hacia la motivación
- "Monolítico" viene del griego: mono (uno) + lithos (piedra) = una sola piedra
- Mostrar que el problema NO es que el código no funcione, sino que es imposible de mantener
- Historia real: "Un estudiante me mostró una función de 500 líneas. Funcionaba. Pero cuando tuvo que arreglar un bug, tardó 3 horas en encontrarlo"
-->

---

<!-- _header: 'El problema' -->

# Código monolítico

```python
# ❌ Función gigante que hace TODO
def sistema_biblioteca():
    """300 líneas de código mezclando:"""
    # - Validar usuarios
    # - Buscar libros
    # - Registrar préstamos
    # - Calcular multas
    # - Generar reportes
    # ... ¡imposible de mantener!
```

<!--
NOTAS DEL ORADOR:
- Mostrar el horror del código "espagueti"
- Preguntar: "¿Dónde buscarían un error de cálculo de multas en 300 líneas?"
- Señalar que esto es MUY común en principiantes (y no tan principiantes)
- Aclarar: funciona, pero es una bomba de tiempo
- Cuando vuelvas en 2 semanas, no vas a entender tu propio código
-->

---

<!-- _header: 'El problema' -->

# Problemas del código monolítico

**Difícil de debuggear:**
Si hay un error, ¿dónde está?

**Difícil de entender:**
¿Qué hace exactamente cada parte?

**No se puede reutilizar:**
Todo está mezclado

**No se puede testear:**
No se puede probar cada parte por separado

<!--
NOTAS DEL ORADOR:
- Ir punto por punto con ejemplos concretos
- Debuggear: "Es como buscar una aguja en un pajar"
- Entender: "Volvé a tu código en 2 semanas... ¿lo vas a entender?"
- Reutilizar: "Si validar_usuario está mezclado con calcular_multas, no lo podés usar en otro programa"
- Testear: "No podés probar el cálculo de multas sin simular todo el sistema"
- Trabajo en equipo: "Si 3 personas tocan la misma función de 300 líneas, conflictos garantizados"
-->

---

<!-- _class: inverse -->

# <!-- fit --> Los 3 Principios
## SRP, Abstracción y DRY

<!--
NOTAS DEL ORADOR:
- Estos son los 3 pilares de la buena descomposición
- SRP: Single Responsibility Principle (viene de SOLID)
- Abstracción: concepto fundamental de la computación
- DRY: Don't Repeat Yourself (ya lo vieron, reforzamos)
- Tip: "Si recuerdan solo una cosa, que sea SRP"
-->

---

<!-- _header: 'Principio 1: SRP' -->

# Responsabilidad Única (SRP)

**Cada función hace UNA sola cosa**

```python
# ❌ Hace demasiadas cosas
def procesar_pedido(cliente, items):
    # Valida cliente
    # Valida stock
    # Calcula precio
    # Aplica descuentos
    # Genera factura
    # Envía email
    # Actualiza inventario
```

<!--
NOTAS DEL ORADOR:
- SRP = Single Responsibility Principle
- Regla simple: "Si usás la palabra 'y' para describir qué hace, tiene más de una responsabilidad"
- Esta función "valida Y calcula Y genera Y envía Y actualiza"
- Contar cuántas responsabilidades tiene: ¡7!
- Pregunta: "¿Qué pasa si cambia cómo se envían emails?" → Tocás función de pedidos
-->

---

<!-- _header: 'Principio 1: SRP' -->

# Aplicando SRP

```python
# ✅ Cada función una responsabilidad
def validar_cliente(cliente):
    """Solo valida datos del cliente."""

def verificar_stock(items):
    """Solo verifica disponibilidad."""

def calcular_total(items, descuento=0):
    """Solo calcula el precio total."""

def generar_factura(pedido):
    """Solo genera el documento."""

def enviar_email(cliente, factura):
    """Solo envía el email."""
```

<!--
NOTAS DEL ORADOR:
- Ahora cada función tiene UN solo trabajo
- Nombres descriptivos que dicen exactamente qué hacen
- Beneficios concretos:
  * Si cambia validación de cliente → solo tocás validar_cliente
  * Si querés reutilizar envío de email → podés
  * Si hay bug en cálculo → sabés exactamente dónde buscar
- Las funciones son cortas, fáciles de entender
- Notar el docstring que refuerza la responsabilidad única
-->

---

<!-- _header: 'Principio 2: Abstracción' -->

# Esconder la complejidad

**Usar algo sin saber cómo funciona internamente**

```python
def procesar_pedido(cliente, items):
    """Orquesta todas las operaciones."""
    validar_cliente(cliente)
    verificar_stock(items)
    total = calcular_total(items)
    factura = generar_factura(cliente, items, total)
    enviar_email(cliente, factura)
    return factura

# ¡Fácil de leer y entender el flujo!
```

<!--
NOTAS DEL ORADOR:
- Abstracción = ocultar detalles de implementación
- Esta función es como un "director de orquesta": coordina a todos pero no toca ningún instrumento
- Analogía: cuando usás print(), no sabés cómo funciona internamente, solo lo usás
- Beneficio clave: podés leer esta función y entender el flujo completo del negocio
- Los detalles de CÓMO se valida o CÓMO se envía el email están escondidos
- "Función de alto nivel" o "función de orquestación"
-->

---

<!-- _header: 'Principio 3: DRY' -->

# Don't Repeat Yourself

**Si hacés algo más de una vez → función**

```python
# ❌ Código repetitivo
edad1 = 2024 - 1998
edad2 = 2024 - 2005
edad3 = 2024 - 1990

# ✅ Función reutilizable
def calcular_edad(año_nacimiento):
    return 2024 - año_nacimiento

edad1 = calcular_edad(1998)
edad2 = calcular_edad(2005)
edad3 = calcular_edad(1990)
```

<!--
NOTAS DEL ORADOR:
- DRY ya lo vieron, pero reforzamos en contexto de descomposición
- Problema del código repetitivo:
  * Si cambia el año → hay que cambiar en 3 lugares
  * Más probabilidad de errores (olvidar uno)
  * Más código para mantener
- Regla práctica: "Si copiás y pegás, probablemente necesitás una función"
- Bonus: función se puede mejorar después (ej: usar datetime para año actual)
- Relacionado con SRP: la lógica de calcular edad está en UN solo lugar
-->

---

<!-- _class: inverse -->

# <!-- fit --> Proceso paso a paso
## Cómo descomponer un problema

<!--
NOTAS DEL ORADOR:
- Ahora vamos a ver el proceso CONCRETO
- 4 pasos que pueden aplicar a cualquier problema
- Vamos a usar un ejemplo real que van a poder replicar
- Tip: "Los primeros problemas van a tomar tiempo, después se vuelve natural"
-->

---

<!-- _header: 'Paso 1' -->

# Identificar tareas principales

**Problema:** Sistema de cálculo de notas

**Requerimientos:**
* Pedir notas de 3 parciales
* Calcular promedio
* Determinar si aprobó (≥6)
* Mostrar mensaje según resultado

<!--
NOTAS DEL ORADOR:
- Primer paso: leer el enunciado con atención
- No pensar en código todavía, pensar en QUÉ hay que hacer
- Listar los requerimientos de manera clara
- Este problema es simple pero ilustrativo
- En problemas reales, esta lista puede ser más larga
-->

---

<!-- _header: 'Paso 1' -->

# Subrayar los verbos

Leé el problema y subrayá los **verbos de acción**:

* **Pedir** notas
* **Calcular** promedio
* **Determinar** si aprobó
* **Mostrar** mensaje

**Cada verbo es potencialmente una función**

<!--
NOTAS DEL ORADOR:
- Técnica clave: buscar los VERBOS en el enunciado
- Los verbos indican acciones = funciones potenciales
- En este caso: 4 verbos = 4 funciones probables
- Ejercicio interactivo: "¿Qué verbos encuentran en este problema?"
- Esta técnica funciona para problemas de cualquier tamaño
- A veces un verbo se descompone en más funciones (ej: "procesar" puede tener varios pasos)
-->

---

<!-- _header: 'Paso 2' -->

# Diseñar la estructura

```python
# Estructura de alto nivel (pseudocódigo)
def main():
    notas = pedir_notas()
    promedio = calcular_promedio(notas)
    aprobado = verificar_aprobacion(promedio)
    mostrar_resultado(promedio, aprobado)
```

**Primero el esqueleto, después los detalles**

<!--
NOTAS DEL ORADOR:
- Ahora escribimos el ESQUELETO del programa
- Las funciones todavía no existen, pero definimos cómo se conectan
- Esto es "programación por wishful thinking": imagino que las funciones existen
- Notar cómo el flujo es claro y legible
- El main() es como el índice de un libro
- Pregunta: "¿Pueden entender qué hace este programa sin ver las funciones?"
- ¡Eso es buena abstracción!
-->

---

<!-- _header: 'Paso 3' -->

# Implementar cada función

```python
def pedir_notas():
    """Solicita las 3 notas al usuario."""
    notas = []
    for i in range(1, 4):
        nota = float(input(f"Nota parcial {i}: "))
        notas.append(nota)
    return notas
```

```python
def calcular_promedio(notas):
    """Calcula el promedio de una lista."""
    return sum(notas) / len(notas)
```

<!--
NOTAS DEL ORADOR:
- Ahora implementamos cada función por separado
- Ventaja: podés concentrarte en UN problema a la vez
- pedir_notas: solo se preocupa por obtener datos
- calcular_promedio: solo hace matemática
- Notar que cada función es corta y fácil de entender
- calcular_promedio es tan simple que casi parece innecesario... pero SRP dice que sí
- Bonus: calcular_promedio se puede reutilizar en otros programas
-->

---

<!-- _header: 'Paso 3' -->

# Implementar cada función (cont.)

```python
def verificar_aprobacion(promedio, minimo=6):
    """Verifica si aprobó."""
    return promedio >= minimo
```

```python
def mostrar_resultado(promedio, aprobado):
    """Muestra el resultado."""
    print(f"Promedio: {promedio:.2f}")
    if aprobado:
        print("Estado: APROBADO")
    else:
        print("Estado: DESAPROBADO")
```

<!--
NOTAS DEL ORADOR:
- verificar_aprobacion: una línea, pero vale la pena porque:
  * El nombre documenta la intención
  * El parámetro minimo=6 es configurable
  * Se puede cambiar la lógica después (ej: agregar condiciones)
- mostrar_resultado: maneja toda la presentación
- Notar la separación de responsabilidades:
  * verificar: lógica de negocio (retorna bool)
  * mostrar: presentación (imprime en pantalla)
- Esta separación permite cambiar cómo mostramos sin tocar la lógica
-->

---

<!-- _header: 'Paso 4' -->

# Analizar los beneficios

| Sin descomposición | Con descomposición |
|:-------------------|:-------------------|
| 80 líneas mezcladas | Funciones separadas |
| Difícil de leer | Fácil de entender |
| No testeable | Cada función testeable |
| No reutilizable | `calcular_promedio` reutilizable |

<!--
NOTAS DEL ORADOR:
- Comparación lado a lado de los beneficios
- Sin descomposición: un bloque de 80 líneas
- Con descomposición: 5-6 funciones de ~10 líneas cada una
- Testing: podés probar calcular_promedio con assert calcular_promedio([6, 8]) == 7
- Reutilización: calcular_promedio sirve para cualquier lista de números
- Pregunta retórica: "¿Cuál preferirían mantener?"
- El código descompuesto es más largo en total, pero mucho más manejable
-->

---

<!-- _class: inverse -->

# <!-- fit --> Estrategias
## Top-Down vs Bottom-Up

<!--
NOTAS DEL ORADOR:
- Hay diferentes formas de abordar la descomposición
- No hay una "correcta", depende del problema y preferencia personal
- Vamos a ver las 3 principales
- En la práctica, se suele mezclar
-->

---

<!-- _header: 'Top-Down' -->

# De arriba hacia abajo

**Empezás con la función principal y vas detallando**

```python
# 1. Función de alto nivel
def procesar_ventas():
    datos = cargar_datos()
    resultados = analizar_datos(datos)
    guardar_resultados(resultados)

# 2. Detallás cada función
def analizar_datos(datos):
    limpios = limpiar_datos(datos)
    stats = calcular_estadisticas(limpios)
    return generar_reporte(stats)
```

**Ventaja:** Ves el panorama completo primero

<!--
NOTAS DEL ORADOR:
- Top-Down: empezás por el "qué" y bajás al "cómo"
- Primero definís el flujo general
- Después implementás cada parte
- Útil cuando tenés claro el problema completo
- Desventaja: las funciones de abajo no están testeadas cuando escribís las de arriba
- Es como planificar un viaje: primero el itinerario, después los detalles
-->

---

<!-- _header: 'Bottom-Up' -->

# De abajo hacia arriba

**Empezás con funciones básicas y construís**

```python
# 1. Funciones básicas
def es_numero_valido(texto):
    return texto.isdigit()

# 2. Funciones de nivel medio
def obtener_numero(mensaje):
    while True:
        entrada = input(mensaje)
        if es_numero_valido(entrada):
            return int(entrada)

# 3. Función de alto nivel
def main():
    edad = obtener_numero("Edad: ")
```

**Ventaja:** Cada pieza testeada antes de combinar

<!--
NOTAS DEL ORADOR:
- Bottom-Up: empezás por las piezas pequeñas
- Construís de menor a mayor
- Útil cuando no tenés claro el panorama completo
- Cada función se puede testear antes de usarla
- Desventaja: podés construir piezas que después no necesitás
- Es como construir con LEGO: primero las piezas, después el castillo
-->

---

<!-- _header: 'Por responsabilidad' -->

# Agrupar por tipo

```python
# === VALIDACIÓN ===
def validar_email(email): ...
def validar_telefono(tel): ...

# === CÁLCULO ===
def calcular_descuento(precio, pct): ...
def calcular_impuestos(monto): ...

# === FORMATO ===
def formatear_fecha(fecha): ...
def formatear_moneda(monto): ...

# === PERSISTENCIA ===
def guardar_archivo(datos): ...
def cargar_archivo(nombre): ...
```

<!--
NOTAS DEL ORADOR:
- Tercera estrategia: agrupar funciones por responsabilidad
- Similar a organizar una biblioteca por temas
- Facilita encontrar funciones relacionadas
- En proyectos grandes, estos grupos se convierten en módulos
- Combinación natural de SRP: funciones del mismo "tipo" juntas
- Útil para trabajo en equipo: "vos hacé validación, yo hago cálculos"
-->

---

<!-- _class: inverse -->

# <!-- fit --> Niveles de abstracción
## Pirámide de funciones

<!--
NOTAS DEL ORADOR:
- Las funciones forman una jerarquía o pirámide
- Arriba: funciones de alto nivel (orquestación)
- Abajo: funciones de bajo nivel (operaciones básicas)
- Cada nivel usa el nivel inferior
- Visualización mental importante para diseñar bien
-->

---

<!-- _header: 'Niveles' -->

# Jerarquía de funciones

**Nivel 1 - Orquestación:**
```python
def procesar_ventas_mensuales():
    ventas = cargar_ventas()
    reporte = generar_reporte(ventas)
    guardar_reporte(reporte)
```

**Nivel 2 - Operaciones principales:**
```python
def generar_reporte(ventas):
    resumen = calcular_resumen(ventas)
    grafico = crear_grafico(ventas)
    return formatear_reporte(resumen, grafico)
```

<!--
NOTAS DEL ORADOR:
- Nivel 1: la función "directora", coordina el flujo general
- Nivel 2: funciones que hacen el trabajo principal
- Notar cómo nivel 1 llama a nivel 2
- El nivel 1 es fácil de leer y entender el flujo
- El nivel 2 tiene los detalles de cada paso principal
-->

---

<!-- _header: 'Niveles' -->

# Jerarquía de funciones (cont.)

**Nivel 3 - Operaciones básicas:**
```python
def calcular_resumen(ventas):
    total = calcular_total(ventas)
    promedio = calcular_promedio(ventas)
    maximo = encontrar_maximo(ventas)
    return {"total": total, "prom": promedio}
```

**Nivel 4 - Operaciones atómicas:**
```python
def calcular_total(ventas):
    return sum(v.monto for v in ventas)
```

<!--
NOTAS DEL ORADOR:
- Nivel 3: funciones que hacen operaciones específicas
- Nivel 4: funciones "atómicas" - las más básicas, una línea
- Nivel 4 es muy reutilizable: calcular_total sirve para muchas cosas
- A medida que bajás de nivel, las funciones son más simples y reutilizables
- La pirámide típica: pocas funciones de nivel 1, muchas de nivel 4
- No todos los programas tienen 4 niveles, depende de la complejidad
-->

---

<!-- _class: inverse -->

# <!-- fit --> Señales de alerta
## Cuándo necesitás descomponer

<!--
NOTAS DEL ORADOR:
- Ahora veamos cómo DETECTAR que una función necesita descomponerse
- Estas son "red flags" o señales de alerta
- Si ven alguna de estas, es hora de dividir
- Con el tiempo esto se vuelve instintivo
-->

---

<!-- _header: 'Señales de alerta' -->

# Tu función necesita descomponerse si...

**Tiene más de 20-30 líneas**

**Usa "y" al describir qué hace:**
"Valida datos **y** calcula resultado **y** muestra output"

**Tiene más de 3 niveles de indentación:**
```python
if condicion1:
    for item in lista:
        if condicion2:
            while algo:  # ¡4 niveles!
```

<!--
NOTAS DEL ORADOR:
- Regla de las 20-30 líneas: no es absoluta, pero es buen indicador
- La prueba del "y": si necesitás la palabra "y" para describir qué hace, tiene múltiples responsabilidades
- Indentación profunda: indica lógica anidada compleja
- 4 niveles de indentación hacen el código muy difícil de seguir
- Ejercicio mental: "¿Puedo describir esta función en UNA oración simple?"
-->

---

<!-- _header: 'Señales de alerta' -->

# Más señales

**Es difícil ponerle nombre**
(hace demasiado)

**Necesitás scrollear para verla completa**

**Tiene secciones separadas por comentarios:**
```python
def funcion():
    # Validar entrada
    # ... 10 líneas ...
    
    # Procesar datos
    # ... 10 líneas ...
    
    # Generar output
    # ... 10 líneas ...
```

<!--
NOTAS DEL ORADOR:
- Si no podés ponerle nombre descriptivo, probablemente hace demasiado
- Nombres como "procesar_todo" o "hacer_cosas" son red flags
- Si scrolleás, no podés ver la función completa en tu cabeza
- Los comentarios de sección son la señal más clara
- Cada sección con comentario debería ser su propia función
- Esos comentarios son "funciones que quieren nacer"
-->

---

<!-- _header: 'Señales de alerta' -->

# La regla de los comentarios

Si tu código tiene secciones con comentarios...

**Cada sección debería ser una función**

```python
# ❌ Secciones con comentarios
def procesar():
    # Validar entrada
    ...
    # Calcular resultado
    ...

# ✅ Funciones separadas
def validar_entrada(): ...
def calcular_resultado(): ...
```

<!--
NOTAS DEL ORADOR:
- Esta es la regla más práctica y fácil de aplicar
- Si escribiste "# Validar entrada", eso debería ser validar_entrada()
- Los comentarios de sección son una señal de que estás pensando en funciones pero no las creaste
- Beneficio: los nombres de función son mejores que comentarios porque:
  * Se pueden reutilizar
  * Se pueden testear
  * Aparecen en stack traces
- Ejercicio: busquen en su código funciones con comentarios de sección y refactoricen
-->

---

<!-- _class: inverse -->

# <!-- fit --> Ejemplo completo
## Sistema de notas paso a paso

<!--
NOTAS DEL ORADOR:
- Vamos a ver el ejemplo completo con todas las funciones
- Este es el código que deberían poder escribir al final de la clase
- Vamos función por función analizando las decisiones de diseño
-->

---

<!-- _header: 'Ejemplo' -->

# El problema

**Sistema de cálculo de notas:**
1. Pedir notas de 3 parciales
2. Calcular promedio
3. Determinar si aprobó (≥6)
4. Mostrar resultado
5. Si no aprobó, calcular nota de recuperatorio

<!--
NOTAS DEL ORADOR:
- Mismo problema de antes, pero ahora con un requerimiento extra
- Punto 5: si no aprobó, calcular qué necesita en el recuperatorio
- Esto agrega una función más al sistema
- Total: 5-6 funciones para un problema "simple"
- En la industria, programas reales tienen cientos de funciones
-->

---

<!-- _header: 'Ejemplo' -->

# Función pedir_notas

```python
def pedir_notas():
    """Solicita las 3 notas al usuario.
    
    Returns:
        list: Lista con las 3 notas.
    """
    notas = []
    for i in range(1, 4):
        while True:
            try:
                nota = float(input(f"Parcial {i}: "))
                if 0 <= nota <= 10:
                    notas.append(nota)
                    break
                print("Nota debe estar entre 0 y 10")
            except ValueError:
                print("Ingresá un número válido")
    return notas
```

<!--
NOTAS DEL ORADOR:
- Esta función es la más larga pero tiene UNA sola responsabilidad: obtener notas válidas
- Incluye validación: rango 0-10 y que sea número
- El while True + break es patrón común para validación
- try/except maneja cuando el usuario escribe texto en vez de número
- Docstring documenta qué retorna
- Pregunta: "¿Se podría descomponer más?" Sí, pero para este nivel está bien
-->

---

<!-- _header: 'Ejemplo' -->

# Funciones de cálculo

```python
def calcular_promedio(notas):
    """Calcula el promedio de una lista."""
    return sum(notas) / len(notas)


def verificar_aprobacion(promedio, minimo=6):
    """Verifica si el promedio es aprobado."""
    return promedio >= minimo


def calcular_nota_recuperatorio(promedio, minimo=6):
    """Calcula nota necesaria en recuperatorio."""
    # promedio * 0.6 + recup * 0.4 = minimo
    return (minimo - promedio * 0.6) / 0.4
```

<!--
NOTAS DEL ORADOR:
- Tres funciones de cálculo puras: solo matemática, sin input/output
- calcular_promedio: una línea, súper reutilizable
- verificar_aprobacion: parámetro minimo=6 permite configurar
- calcular_nota_recuperatorio: fórmula ponderada 60% parciales + 40% recup
- Notar el comentario con la fórmula: ayuda a entender la matemática
- Todas retornan valores, no imprimen nada
- Esto las hace fáciles de testear: assert calcular_promedio([6, 8]) == 7
-->

---

<!-- _header: 'Ejemplo' -->

# Función de presentación

```python
def mostrar_resultado(promedio, aprobado):
    """Muestra el resultado de la evaluación."""
    print(f"\n{'='*40}")
    print(f"Promedio: {promedio:.2f}")
    
    if aprobado:
        print("Estado: APROBADO")
        if promedio >= 8:
            print("¡Excelente trabajo!")
    else:
        print("Estado: DESAPROBADO")
    
    print(f"{'='*40}\n")
```

<!--
NOTAS DEL ORADOR:
- Esta función solo maneja la PRESENTACIÓN
- No calcula nada, solo recibe datos y los muestra
- Separación importante: si querés cambiar cómo se ve, solo tocás esta función
- El formato con = es decorativo, fácil de cambiar
- Mensaje extra "Excelente trabajo" si promedio >= 8
- Notar que recibe "aprobado" como bool, no calcula si aprobó
-->

---

<!-- _header: 'Ejemplo' -->

# Función principal

```python
def main():
    """Función principal que orquesta todo."""
    print("Sistema de Cálculo de Notas")
    print("="*40)
    
    notas = pedir_notas()
    promedio = calcular_promedio(notas)
    aprobado = verificar_aprobacion(promedio)
    mostrar_resultado(promedio, aprobado)
    
    if not aprobado:
        recup = calcular_nota_recuperatorio(promedio)
        print(f"Necesitás {recup:.2f} en recuperatorio")

if __name__ == "__main__":
    main()
```

<!--
NOTAS DEL ORADOR:
- main() es el director de orquesta: coordina pero no hace el trabajo
- Muy fácil de leer: el flujo del programa es claro
- Cada línea es una llamada a función con nombre descriptivo
- La lógica condicional (if not aprobado) está en main porque es flujo de control
- if __name__ == "__main__": permite importar el módulo sin ejecutar main
- Pregunta: "¿Pueden entender qué hace este programa leyendo solo main?"
-->

---

<!-- _header: 'Ejemplo' -->

# Análisis de la descomposición

| Función | Responsabilidad | Reutilizable |
|:--------|:----------------|:-------------|
| `pedir_notas` | Input | Parcial |
| `calcular_promedio` | Cálculo | ✅ Sí |
| `verificar_aprobacion` | Lógica | ✅ Sí |
| `mostrar_resultado` | Output | Parcial |
| `calcular_nota_recuperatorio` | Cálculo | ✅ Sí |
| `main` | Orquestación | No |

<!--
NOTAS DEL ORADOR:
- Análisis de cada función según su rol
- Las funciones de cálculo son 100% reutilizables: puro input → output
- pedir_notas y mostrar_resultado son parcialmente reutilizables: dependen de consola
- main no es reutilizable: es específico de este programa
- Este patrón (funciones puras + funciones de I/O + main) es muy común
- Las funciones puras son las más fáciles de testear
- Ejercicio: "¿Cómo testearían calcular_promedio?"
-->

---

<!-- _class: inverse -->

# <!-- fit --> Checklist
## Verificá tu descomposición

<!--
NOTAS DEL ORADOR:
- Lista de verificación para antes de entregar código
- Usala como guía cuando termines de programar
- Con el tiempo, estas verificaciones se vuelven automáticas
-->

---

<!-- _header: 'Checklist' -->

# Antes de dar por terminado

- [ ] Cada función tiene nombre descriptivo
- [ ] Cada función hace una sola cosa (SRP)
- [ ] Las funciones tienen menos de 20 líneas
- [ ] No hay código repetido (DRY)
- [ ] Cada función está documentada
- [ ] Las funciones son testeables por separado
- [ ] `main()` es fácil de leer y entender

<!--
NOTAS DEL ORADOR:
- Checklist práctico para autoevaluación
- No hace falta cumplir TODOS siempre, pero son buenos objetivos
- Nombre descriptivo: si el nombre no dice qué hace, renombrar
- SRP: una oración para describir, sin "y"
- 20 líneas: regla flexible pero útil
- DRY: buscar código duplicado y extraer a función
- Documentada: al menos docstring de una línea
- Testeable: ¿puedo llamar la función aislada y verificar resultado?
- main() legible: el flujo del programa debe ser obvio
-->

---

<!-- _header: 'Resumen' -->

# Para recordar

**Descomposición funcional:**
* Dividir problema en subproblemas
* Cada subproblema → una función

**Principios:**
* SRP: Una función, una cosa
* Abstracción: Esconder complejidad
* DRY: No repetir código

**Proceso:**
* Identificar verbos de acción
* Diseñar estructura de alto nivel
* Implementar cada función

<!--
NOTAS DEL ORADOR:
- Resumen de los puntos clave
- Descomposición es la habilidad más importante después de saber la sintaxis
- Los 3 principios guían todas las decisiones
- El proceso de 4 pasos es aplicable a cualquier problema
- Práctica: tomar cualquier problema y pasar por los 4 pasos
- Siguiente clase o práctica: ejercicios de descomposición
-->

---

<!-- _class: centered -->

# ¿Preguntas?

<!--
NOTAS DEL ORADOR:
- Abrir a preguntas
- Preguntas guía si no hay:
  * "¿Cuál de los 3 principios les parece más difícil de aplicar?"
  * "¿Alguna vez escribieron una función muy larga? ¿Cómo la dividirían ahora?"
  * "¿Qué pasa si no saben cuántas funciones crear?"
- Tarea sugerida: tomar un programa anterior y refactorizarlo con descomposición
- Próxima clase: práctica con ejercicios de descomposición
-->
